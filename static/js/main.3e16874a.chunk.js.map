{"version":3,"sources":["utility.js","ColoredSquareScene.js","ColoredCubeScene.js","TexturedCubeScene.js","LightedCubeModel.js","LightedCubeScene.js","MazeModel.js","MazeScene.js","BrickWallModel.js","BrickWallScene.js","App.js","serviceWorker.js","index.js"],"names":["initShaderProgram","gl","vsSource","fsSource","vertexShader","_loadShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","alert","getProgramInfoLog","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","loadTexture","url","texture","createTexture","bindTexture","TEXTURE_2D","internalFormat","RGBA","srcFormat","srcType","UNSIGNED_BYTE","pixel","Uint8Array","texImage2D","image","Image","onload","_isPowerOf2","width","height","generateMipmap","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","src","value","clearScreen","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","_directions","x","y","generateMaze","windiness","carve","pos","data","canCarve","dir","isInBounds","addDir","nxt","len","push","Array","fill","lastDir","start","cells","length","cell","posCells","i","includes","Math","random","floor","pop","ColoredSquareScene","this","initScene","bind","drawScene","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexColor","uniformLocations","projectionMatrix","getUniformLocation","modelViewMatrix","buffers","_initBuffers","scene","squareRotation","deltaTime","FLOAT","bindBuffer","ARRAY_BUFFER","color","vertexAttribPointer","enableVertexAttribArray","position","fieldOfView","PI","aspect","canvas","clientWidth","clientHeight","mat4","useProgram","uniformMatrix4fv","drawArrays","TRIANGLE_STRIP","createBuffer","bufferData","Float32Array","STATIC_DRAW","ColoredCubeScene","cubeRotation","ELEMENT_ARRAY_BUFFER","indices","UNSIGNED_SHORT","drawElements","TRIANGLES","positionBuffer","faceColors","colors","j","c","concat","colorBuffer","indexBuffer","Uint16Array","TexturedCubeScene","textureCoord","uSampler","activeTexture","TEXTURE0","uniform1i","textureCoordBuffer","LightedCubeModel","draw","_initShaders","shaderProgramPerPixel","_initShadersPerPixel","model","vertexNormal","normalMatrix","ambientLight","directionalLight","direction","pointLight","shaderPerPixel","viewMatrix","modelMatrix","perPixel","normal","uniform3f","vec3","uniform3fv","normalBuffer","LightedCubeScene","actors","location","rotation","rotationSpeed","camera","cameraDir","actor","_renderActor","_animateActor","MazeModel","maze","_freeBuffers","vertexCount","UNSIGNED_INT","positions","offset","addSquareXY","left","right","top","bottom","base","addSquareXZ","addSquareYZ","floorColor","ceilingColor","wallColor_Top","wallColor_Bottom","wallColor_Left","wallColor_Right","ofs_x","ofs_y","Uint32Array","deleteBuffer","MazeScene","totalDelta","size","angle","axis","speed","update","BrickWallModel","vertexTangent","vertexBitangent","textureNormal","textureDiffuse","showTexture","cameraPosition","diffuse","tangent","bitangent","TEXTURE1","tangents","bitangents","textureCoordinates","addSquare","c0","c1","c2","c3","f0","f1","f2","f3","b0","b1","b2","b3","tangentBuffer","bitangentBuffer","BrickWallScene","rotations","App","props","onClickCanvas","renderCanvas","scenes","init","render","sceneIndex","rect","getBoundingClientRect","getContext","CULL_FACE","cullFace","BACK","getExtension","frame","window","requestAnimationFrame","cancelAnimationFrame","event","preventDefault","timeStamp","className","ref","elem","onClick","React","Component","Boolean","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3e16874a.chunk.js","sourcesContent":["export function degreesToRadians(degrees) {\r\n  var pi = Math.PI;\r\n  return degrees * (pi / 180);\r\n}\r\n\r\nexport function initShaderProgram(gl, vsSource, fsSource) {\r\n  const vertexShader = _loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n  const fragmentShader = _loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n  const shaderProgram = gl.createProgram();\r\n  gl.attachShader(shaderProgram, vertexShader);\r\n  gl.attachShader(shaderProgram, fragmentShader);\r\n  gl.linkProgram(shaderProgram);\r\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n    return null;\r\n  }\r\n  return shaderProgram;\r\n}\r\n\r\nfunction _loadShader(gl, type, source) {\r\n  const shader = gl.createShader(type);\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n    return null;\r\n  }\r\n  return shader;\r\n}\r\n\r\nexport function loadTexture(gl, url) {\r\n  const texture = gl.createTexture();\r\n  gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  const level = 0;\r\n  const internalFormat = gl.RGBA;\r\n  const width = 1;\r\n  const height = 1;\r\n  const border = 0;\r\n  const srcFormat = gl.RGBA;\r\n  const srcType = gl.UNSIGNED_BYTE;\r\n  const pixel = new Uint8Array([0, 0, 255, 255]);\r\n  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);\r\n  const image = new Image();\r\n  image.onload = () => {\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\r\n      srcFormat, srcType, image);\r\n    if (_isPowerOf2(image.width) && _isPowerOf2(image.height)) {\r\n      gl.generateMipmap(gl.TEXTURE_2D);\r\n    } else {\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    }\r\n  };\r\n  image.src = url;\r\n  return texture;\r\n}\r\n\r\nfunction _isPowerOf2(value) {\r\n  return (value & (value - 1)) === 0;\r\n}\r\n\r\nexport function clearScreen(gl) {\r\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n  gl.clearDepth(1.0);\r\n  gl.enable(gl.DEPTH_TEST);\r\n  gl.depthFunc(gl.LEQUAL);\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n}\r\n\r\nconst _directions = [\r\n  { x: -1, y: 0 },\r\n  { x: 0, y: -1 },\r\n  { x: 1, y: 0 },\r\n  { x: 0, y: 1 }\r\n];\r\n\r\nexport function generateMaze(width, height, windiness = 0.8) {\r\n  const carve = (pos) => {\r\n    data[pos.y][pos.x] = 0;\r\n  }\r\n\r\n  const canCarve = (pos, dir) => {\r\n    if (!isInBounds(addDir(pos, dir, 3))) {\r\n      return false;\r\n    }\r\n    const nxt = addDir(pos, dir, 2);\r\n    return data[nxt.y][nxt.x] === 1;\r\n  }\r\n\r\n  const isInBounds = (pos) => {\r\n    if (pos.x < 0 || pos.y < 0 || pos.x >= width || pos.y >= height) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  const addDir = (pos, dir, len) => {\r\n    return {\r\n      x: pos.x + dir.x * len,\r\n      y: pos.y + dir.y * len\r\n    }\r\n  }\r\n\r\n  const data = [];\r\n  for (let y = 0; y < height; y++) {\r\n    data.push(new Array(width).fill(1));\r\n  }\r\n\r\n  const start = { x: 1, y: 1 };\r\n  const cells = [];\r\n  let lastDir;\r\n  carve(start);\r\n  cells.push(start);\r\n  while (cells.length > 0) {\r\n    const cell = cells[cells.length - 1];\r\n    const posCells = [];\r\n    for (let i = 0; i < _directions.length; i++) {\r\n      const dir = _directions[i];\r\n      if (canCarve(cell, dir)) {\r\n        posCells.push(dir);\r\n      }\r\n    }\r\n    if (posCells.length > 0) {\r\n      let dir;\r\n      if (posCells.includes(lastDir) && Math.random() > windiness) {\r\n        dir = lastDir;\r\n      } else {\r\n        dir = posCells[Math.floor(Math.random() * posCells.length)];\r\n      }\r\n      carve(addDir(cell, dir, 1));\r\n      carve(addDir(cell, dir, 2));\r\n      cells.push(addDir(cell, dir, 2));\r\n      lastDir = dir;\r\n    } else {\r\n      cells.pop();\r\n      lastDir = null;\r\n    }\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    data\r\n  };\r\n}\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, clearScreen } from './utility'\r\n\r\nclass ColoredSquareScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, squareRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.squareRotation, [0, 0, 1]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const offset = 0;\r\n      const vertexCount = 4;\r\n      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\r\n    }\r\n\r\n    scene.squareRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      1.0, 1.0,\r\n      -1.0, 1.0,\r\n      1.0, -1.0,\r\n      -1.0, -1.0,\r\n    ];\r\n    const position = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, position);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const colors = [\r\n      1.0, 1.0, 1.0, 1.0,\r\n      1.0, 0.0, 0.0, 1.0,\r\n      0.0, 1.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0, 1.0\r\n    ];\r\n    const color = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, color);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    return { position, color };\r\n  }\r\n}\r\n\r\nexport default ColoredSquareScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, clearScreen } from './utility'\r\n\r\nclass ColoredCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const faceColors = [\r\n      [1.0, 1.0, 1.0, 1.0],    // Front face: white\r\n      [1.0, 0.0, 0.0, 1.0],    // Back face: red\r\n      [0.0, 1.0, 0.0, 1.0],    // Top face: green\r\n      [0.0, 0.0, 1.0, 1.0],    // Bottom face: blue\r\n      [1.0, 1.0, 0.0, 1.0],    // Right face: yellow\r\n      [1.0, 0.0, 1.0, 1.0],    // Left face: purple\r\n    ];\r\n    let colors = [];\r\n    for (let j = 0; j < faceColors.length; ++j) {\r\n      const c = faceColors[j];\r\n      colors = colors.concat(c, c, c, c);\r\n    }\r\n    const colorBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, color: colorBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default ColoredCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, loadTexture, clearScreen } from './utility'\r\n\r\nclass TexturedCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec2 aTextureCoord;\r\n\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying highp vec2 vTextureCoord;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying highp vec2 vTextureCoord;\r\n\r\n      uniform sampler2D uSampler;\r\n\r\n      void main(void) {\r\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n      }\r\n    `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n        uSampler: gl.getUniformLocation(shaderProgram, 'uSampler')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    const texture = loadTexture(gl, 'images/cubetexture.png');\r\n\r\n    this.scene = { programInfo, buffers, texture, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers, texture } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.textureCoord,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.uniform1i(programInfo.uniformLocations.uSampler, 0);\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const textureCoordinates = [\r\n      // Front\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Back\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Top\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Bottom\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Right\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Left\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n    ];\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default TexturedCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport * as vec3 from 'gl-matrix/vec3';\r\nimport { loadTexture, initShaderProgram } from './utility'\r\n\r\nclass LightedCubeModel {\r\n  constructor(gl) {\r\n    this.gl = gl;\r\n    this.draw = this.draw.bind(this);\r\n    const shaderProgram = this._initShaders(gl);\r\n    const shaderProgramPerPixel = this._initShadersPerPixel(gl);\r\n    this.model = {\r\n      shader: {\r\n        program: shaderProgram,\r\n        attribLocations: {\r\n          vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n          vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),\r\n          textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord')\r\n        },\r\n        uniformLocations: {\r\n          projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n          modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n          normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),\r\n          uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),\r\n          ambientLight: gl.getUniformLocation(shaderProgram, 'uAmbientLight'),\r\n          directionalLight: {\r\n            direction: gl.getUniformLocation(shaderProgram, 'uDirectionalLight.direction'),\r\n            color: gl.getUniformLocation(shaderProgram, 'uDirectionalLight.color')\r\n          },\r\n          pointLight: {\r\n            position: gl.getUniformLocation(shaderProgram, 'uPointLight.position'),\r\n            color: gl.getUniformLocation(shaderProgram, 'uPointLight.color')\r\n          }\r\n        }\r\n      },\r\n      shaderPerPixel: {\r\n        program: shaderProgramPerPixel,\r\n        attribLocations: {\r\n          vertexPosition: gl.getAttribLocation(shaderProgramPerPixel, 'aVertexPosition'),\r\n          vertexNormal: gl.getAttribLocation(shaderProgramPerPixel, 'aVertexNormal'),\r\n          textureCoord: gl.getAttribLocation(shaderProgramPerPixel, 'aTextureCoord')\r\n        },\r\n        uniformLocations: {\r\n          projectionMatrix: gl.getUniformLocation(shaderProgramPerPixel, 'uProjectionMatrix'),\r\n          modelViewMatrix: gl.getUniformLocation(shaderProgramPerPixel, 'uModelViewMatrix'),\r\n          normalMatrix: gl.getUniformLocation(shaderProgramPerPixel, 'uNormalMatrix'),\r\n          uSampler: gl.getUniformLocation(shaderProgramPerPixel, 'uSampler'),\r\n          ambientLight: gl.getUniformLocation(shaderProgramPerPixel, 'uAmbientLight'),\r\n          directionalLight: {\r\n            direction: gl.getUniformLocation(shaderProgramPerPixel, 'uDirectionalLight.direction'),\r\n            color: gl.getUniformLocation(shaderProgramPerPixel, 'uDirectionalLight.color')\r\n          },\r\n          pointLight: {\r\n            position: gl.getUniformLocation(shaderProgramPerPixel, 'uPointLight.position'),\r\n            color: gl.getUniformLocation(shaderProgramPerPixel, 'uPointLight.color')\r\n          }\r\n        }\r\n      },\r\n      buffers: this._initBuffers(gl),\r\n      texture: loadTexture(gl, 'images/cubetexture.png')\r\n    }\r\n  }\r\n\r\n  draw(projectionMatrix, viewMatrix, modelMatrix, perPixel) {\r\n    const gl = this.gl;\r\n    const { buffers, texture } = this.model;\r\n\r\n    let shader;\r\n    if (perPixel) {\r\n      shader = this.model.shaderPerPixel;\r\n    } else {\r\n      shader = this.model.shader;\r\n    }\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(shader.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(shader.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);\r\n      gl.vertexAttribPointer(shader.attribLocations.vertexNormal, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(shader.attribLocations.vertexNormal);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(shader.attribLocations.textureCoord, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(shader.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    const normalMatrix = mat4.create();\r\n    mat4.invert(normalMatrix, modelMatrix);\r\n    mat4.transpose(normalMatrix, normalMatrix);\r\n\r\n    const modelViewMatrix = mat4.create();\r\n    mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);\r\n\r\n    gl.useProgram(shader.program);\r\n    gl.uniformMatrix4fv(shader.uniformLocations.projectionMatrix, false, projectionMatrix);\r\n    gl.uniformMatrix4fv(shader.uniformLocations.modelViewMatrix, false, modelViewMatrix);\r\n    gl.uniformMatrix4fv(shader.uniformLocations.normalMatrix, false, normalMatrix);\r\n\r\n    gl.uniform3f(shader.uniformLocations.ambientLight, 0.3, 0.3, 0.3);\r\n\r\n    const direction = vec3.fromValues(0.0, 1.0, 0.0);\r\n    vec3.normalize(direction, direction);\r\n    gl.uniform3f(shader.uniformLocations.directionalLight.color, 0.5, 0.5, 0.5);\r\n    gl.uniform3fv(shader.uniformLocations.directionalLight.direction, direction);\r\n\r\n    gl.uniform3f(shader.uniformLocations.pointLight.color, 0.7, 0.7, 0.7);\r\n    gl.uniform3f(shader.uniformLocations.pointLight.position, 0.0, 0.0, 0.0);\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.uniform1i(shader.uniformLocations.uSampler, 0);\r\n\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n  }\r\n\r\n  _initShaders(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec3 aVertexNormal;\r\n      attribute vec2 aTextureCoord;\r\n\r\n      uniform mat4 uProjectionMatrix;\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uNormalMatrix;\r\n      uniform vec3 uAmbientLight;\r\n      uniform struct {\r\n        vec3 direction;\r\n        vec3 color;\r\n      } uDirectionalLight;\r\n      uniform struct {\r\n        vec3 position;\r\n        vec3 color;\r\n      } uPointLight;\r\n\r\n      varying highp vec2 vTextureCoord;\r\n      varying highp vec3 vLighting;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n\r\n        highp vec3 transformedNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));\r\n        highp float directional = max(dot(transformedNormal, uDirectionalLight.direction), 0.0);\r\n\r\n        vec3 surfaceToLight = uPointLight.position - aVertexPosition.xyz;\r\n        float bright = 50.0 * max(dot(transformedNormal, normalize(surfaceToLight)), 0.0) / (length(surfaceToLight) * length(surfaceToLight));\r\n        bright = clamp(bright, 0.0, 1.0);\r\n\r\n        vLighting = uAmbientLight + (uDirectionalLight.color * directional) + (uPointLight.color * bright);\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying highp vec2 vTextureCoord;\r\n      varying highp vec3 vLighting;\r\n\r\n      uniform sampler2D uSampler;\r\n\r\n      void main(void) {\r\n        highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\r\n        gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\r\n      }\r\n    `;\r\n\r\n    return initShaderProgram(gl, vsSource, fsSource);\r\n  }\r\n\r\n  _initShadersPerPixel(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec2 aTextureCoord;\r\n      attribute vec3 aVertexNormal;\r\n\r\n      uniform mat4 uProjectionMatrix;\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uNormalMatrix;\r\n\r\n      varying vec3 vVertexPosition;\r\n      varying vec2 vTextureCoord;\r\n      varying vec3 vVertexNormal;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n        vVertexNormal = normalize(vec3(uNormalMatrix * vec4(aVertexNormal, 1.0)));\r\n        vVertexPosition = vec3(uModelViewMatrix * aVertexPosition);\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      precision highp float;\r\n\r\n      uniform sampler2D uSampler;\r\n      uniform vec3 uAmbientLight;     \r\n      uniform struct {\r\n        vec3 direction;\r\n        vec3 color;\r\n      } uDirectionalLight;\r\n      uniform struct {\r\n        vec3 position;\r\n        vec3 color;\r\n      } uPointLight;\r\n\r\n      varying vec3 vVertexPosition;\r\n      varying vec2 vTextureCoord;\r\n      varying vec3 vVertexNormal;\r\n      \r\n      void main() {\r\n        highp float directional = max(dot(vVertexNormal, uDirectionalLight.direction), 0.0);\r\n\r\n        vec3 surfaceToLight = uPointLight.position - vVertexPosition;\r\n        float bright = 50.0 * max(dot(vVertexNormal, normalize(surfaceToLight)), 0.0) / (length(surfaceToLight) * length(surfaceToLight));\r\n        bright = clamp(bright, 0.0, 1.0);\r\n\r\n        highp vec3 lighting = uAmbientLight + (uDirectionalLight.color * directional) + (uPointLight.color * bright);\r\n\r\n        highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\r\n        gl_FragColor = vec4(texelColor.rgb * lighting, texelColor.a);\r\n      }\r\n    `;\r\n\r\n    return initShaderProgram(gl, vsSource, fsSource);\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const vertexNormals = [\r\n      // Front\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n\r\n      // Back\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n\r\n      // Top\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n\r\n      // Bottom\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n\r\n      // Right\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n\r\n      // Left\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0\r\n    ];\r\n\r\n    const normalBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);\r\n\r\n    const textureCoordinates = [\r\n      // Front\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Back\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Top\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Bottom\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Right\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Left\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n    ];\r\n\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      // Front\r\n      0, 1, 2, 0, 2, 3,\r\n\r\n      // Back\r\n      4, 5, 6, 4, 6, 7,\r\n\r\n      // Top\r\n      8, 9, 10, 8, 10, 11,\r\n\r\n      // Bottom\r\n      12, 13, 14, 12, 14, 15,\r\n\r\n      // Right\r\n      16, 17, 18, 16, 18, 19,\r\n\r\n      // Left\r\n      20, 21, 22, 20, 22, 23,\r\n    ];\r\n\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, normal: normalBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default LightedCubeModel;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { clearScreen } from './utility'\r\nimport LightedCubeModel from './LightedCubeModel';\r\n\r\nclass LightedCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const model = new LightedCubeModel(gl);\r\n    this.scene = {\r\n      actors: [\r\n        {\r\n          model,\r\n          location: [-2.0, 0.0, -5.5],\r\n          rotation: 0.0,\r\n          rotationSpeed: 1.0,\r\n          perPixel: false\r\n        },\r\n        {\r\n          model,\r\n          location: [2.0, 0.0, -5.5],\r\n          rotation: 0.0,\r\n          rotationSpeed: 1.0,\r\n          perPixel: true\r\n        }\r\n      ],\r\n      camera: [0.0, 0.0, 0.0],\r\n      cameraDir: [0.0, 0.0, 2.0]\r\n    };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    const fieldOfView = 45 * Math.PI / 180;\r\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n    const zNear = 0.1;\r\n    const zFar = 100.0;\r\n    const projectionMatrix = mat4.create();\r\n    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n\r\n    const viewMatrix = mat4.create();\r\n    mat4.translate(viewMatrix, viewMatrix, scene.camera);\r\n    mat4.invert(viewMatrix, viewMatrix)\r\n\r\n    for (let i = 0; i < scene.actors.length; i++) {\r\n      const actor = scene.actors[i];\r\n      this._renderActor(projectionMatrix, viewMatrix, actor);\r\n      this._animateActor(deltaTime, actor);\r\n    }\r\n\r\n    if (scene.camera[2] > 16.0) {\r\n      scene.camera[2] = 16.0;\r\n      scene.cameraDir[2] = -2.0;\r\n    } else if (scene.camera[2] < 0.0) {\r\n      scene.camera[2] = 0.0;\r\n      scene.cameraDir[2] = 2.0;\r\n    }\r\n\r\n    scene.camera[0] += scene.cameraDir[0] * deltaTime;\r\n    scene.camera[1] += scene.cameraDir[1] * deltaTime;\r\n    scene.camera[2] += scene.cameraDir[2] * deltaTime;\r\n  }\r\n\r\n  _renderActor(projectionMatrix, viewMatrix, actor) {\r\n    const model = actor.model;\r\n\r\n    const modelMatrix = mat4.create();\r\n    mat4.translate(modelMatrix, modelMatrix, actor.location);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation, [0, 0, 1]);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation * 0.7, [0, 1, 0]);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation * 0.3, [1, 0, 0]);\r\n\r\n    model.draw(projectionMatrix, viewMatrix, modelMatrix, actor.perPixel);\r\n  }\r\n\r\n  _animateActor(deltaTime, actor) {\r\n    actor.rotation += deltaTime * actor.rotationSpeed;\r\n  }\r\n}\r\n\r\nexport default LightedCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram } from './utility'\r\n\r\nclass MazeModel {\r\n  constructor(gl, maze) {\r\n    this.gl = gl;\r\n    this.maze = maze;\r\n    this.draw = this.draw.bind(this);\r\n    const shaderProgram = this._initShaders(gl);\r\n    this.model = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      },\r\n      buffers: this._initBuffers(gl, maze)\r\n    }\r\n  }\r\n\r\n  update(maze) {\r\n    this._freeBuffers(this.gl, this.model.buffers);\r\n    this.maze = maze;\r\n    this.model.buffers = this._initBuffers(this.gl, maze);\r\n  }\r\n\r\n  draw(projectionMatrix, viewMatrix, modelMatrix) {\r\n    const gl = this.gl;\r\n    const model = this.model;\r\n    const { buffers } = this.model;\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(model.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(model.attribLocations.vertexColor, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.vertexColor);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    const modelViewMatrix = mat4.create();\r\n    mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);\r\n\r\n    gl.useProgram(model.program);\r\n    gl.uniformMatrix4fv(model.uniformLocations.projectionMatrix, false, projectionMatrix);\r\n    gl.uniformMatrix4fv(model.uniformLocations.modelViewMatrix, false, modelViewMatrix);\r\n\r\n    {\r\n      const vertexCount = buffers.vertexCount;\r\n      const type = gl.UNSIGNED_INT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n  }\r\n\r\n  _initShaders(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec4 aVertexColor;\r\n\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying lowp vec4 vColor;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vColor = aVertexColor;\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying lowp vec4 vColor;\r\n\r\n      void main(void) {\r\n        gl_FragColor = vColor;\r\n      }\r\n    `;\r\n\r\n    return initShaderProgram(gl, vsSource, fsSource);\r\n  }\r\n\r\n  _initBuffers(gl, maze) {\r\n    const positions = []\r\n    const colors = [];\r\n    const indices = [];\r\n    let offset = 0;\r\n\r\n    const addSquareXY = (left, right, top, bottom, base, color) => {\r\n      positions.push\r\n        (\r\n          left, top, base,\r\n          right, top, base,\r\n          right, bottom, base,\r\n          left, bottom, base\r\n        );\r\n      indices.push\r\n        (\r\n          offset + 0, offset + 1, offset + 2, offset + 0, offset + 2, offset + 3\r\n        );\r\n      offset += 4;\r\n      for (let i = 0; i < 4; i++) {\r\n        for (let j = 0; j < 4; j++) {\r\n          colors.push(color[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    const addSquareXZ = (left, right, top, bottom, base, color) => {\r\n      positions.push\r\n        (\r\n          left, base, top,\r\n          right, base, top,\r\n          right, base, bottom,\r\n          left, base, bottom\r\n        );\r\n      indices.push\r\n        (\r\n          offset + 0, offset + 1, offset + 2, offset + 0, offset + 2, offset + 3\r\n        );\r\n      offset += 4;\r\n      for (let i = 0; i < 4; i++) {\r\n        for (let j = 0; j < 4; j++) {\r\n          colors.push(color[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    const addSquareYZ = (left, right, top, bottom, base, color) => {\r\n      positions.push\r\n        (\r\n          base, left, top,\r\n          base, right, top,\r\n          base, right, bottom,\r\n          base, left, bottom\r\n        );\r\n      indices.push\r\n        (\r\n          offset + 0, offset + 1, offset + 2, offset + 0, offset + 2, offset + 3\r\n        );\r\n      offset += 4;\r\n      for (let i = 0; i < 4; i++) {\r\n        for (let j = 0; j < 4; j++) {\r\n          colors.push(color[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    const floorColor = [.2, .2, .2, 1.0];\r\n    const ceilingColor = [.7, .7, .7, 1];\r\n    const wallColor_Top = [.5, 0, .5, 1];\r\n    const wallColor_Bottom = [0, .5, 0, 1];\r\n    const wallColor_Left = [.5, 0, 0, 1];\r\n    const wallColor_Right = [0, .0, .5, 1];\r\n\r\n    const ofs_x = -maze.width / 2;\r\n    const ofs_y = -maze.height / 2;\r\n    for (let y = 0; y < maze.height; y++) {\r\n      for (let x = 0; x < maze.width; x++) {\r\n        const left = x + ofs_x;\r\n        const right = left + 1;\r\n        const top = y + ofs_y;\r\n        const bottom = top + 1;\r\n\r\n        if (maze.data[y][x] === 0) {\r\n          addSquareXY(left, right, top, bottom, 0.0, floorColor);\r\n        } else {\r\n          addSquareXY(left, right, top, bottom, 1.0, ceilingColor);\r\n\r\n          if (y === 0 || maze.data[y - 1][x] === 0) {\r\n            addSquareXZ(left, right, 0.0, 1.0, top, wallColor_Top);\r\n          }\r\n\r\n          if (x === 0 || maze.data[y][x - 1] === 0) {\r\n            addSquareYZ(bottom, top, 0.0, 1.0, left, wallColor_Left);\r\n          }\r\n\r\n          if (y === maze.height - 1 || maze.data[y + 1][x] === 0) {\r\n            addSquareXZ(right, left, 0.0, 1.0, bottom, wallColor_Bottom);\r\n          }\r\n\r\n          if (x === maze.width - 1 || maze.data[y][x + 1] === 0) {\r\n            addSquareYZ(top, bottom, 0.0, 1.0, right, wallColor_Right);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const colorBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, color: colorBuffer, indices: indexBuffer, vertexCount: indices.length };\r\n  }\r\n\r\n  _freeBuffers(gl, buffers) {\r\n    gl.deleteBuffer(buffers.position);\r\n    gl.deleteBuffer(buffers.color);\r\n    gl.deleteBuffer(buffers.indices);\r\n  }\r\n}\r\n\r\nexport default MazeModel;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { clearScreen, degreesToRadians, generateMaze } from './utility'\r\nimport MazeModel from './MazeModel';\r\n\r\nclass MazeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n    this.totalDelta = 0.0;\r\n  }\r\n\r\n  initScene(gl) {\r\n    const size = Math.floor(Math.random() * 45) * 2 + 11;\r\n    const maze = generateMaze(size, size);\r\n    const model = new MazeModel(gl, maze);\r\n    this.scene = {\r\n      actors: [\r\n        {\r\n          model,\r\n          location: [0.0, 0.0, -2.0 * size],\r\n          rotation: { angle: 0.0, axis: [0, 0, 1], speed: 0.5 }\r\n        }\r\n      ],\r\n      camera: [0.0, 0.0, 0.0],\r\n      cameraDir: [0.0, 0.0, 8.0]\r\n    };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    const fieldOfView = 45 * Math.PI / 180;\r\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n    const zNear = 0.1;\r\n    const zFar = 500.0;\r\n    const projectionMatrix = mat4.create();\r\n    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n\r\n    const viewMatrix = mat4.create();\r\n    mat4.translate(viewMatrix, viewMatrix, scene.camera);\r\n    mat4.invert(viewMatrix, viewMatrix)\r\n\r\n    for (let i = 0; i < scene.actors.length; i++) {\r\n      const actor = scene.actors[i];\r\n      this._renderActor(projectionMatrix, viewMatrix, actor);\r\n      this._animateActor(deltaTime, actor);\r\n    }\r\n  }\r\n\r\n  _renderActor(projectionMatrix, viewMatrix, actor) {\r\n    const model = actor.model;\r\n\r\n    const modelMatrix = mat4.create();\r\n    mat4.translate(modelMatrix, modelMatrix, actor.location);\r\n    mat4.rotate(modelMatrix, modelMatrix, degreesToRadians(-45), [1, 0, 0]);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation.angle, actor.rotation.axis);\r\n\r\n    model.draw(projectionMatrix, viewMatrix, modelMatrix);\r\n  }\r\n\r\n  _animateActor(deltaTime, actor) {\r\n    actor.rotation.angle += deltaTime * actor.rotation.speed;\r\n    this.totalDelta += deltaTime;\r\n    if (this.totalDelta >= 10.0) {\r\n      this.totalDelta -= 10.0;\r\n      const size = Math.floor(Math.random() * 45) * 2 + 11;\r\n      const maze = generateMaze(size, size);\r\n      actor.location[2] = -2.0 * size;\r\n      actor.model.update(maze);\r\n    }\r\n  }\r\n}\r\n\r\nexport default MazeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport * as vec3 from 'gl-matrix/vec3';\r\nimport { loadTexture, initShaderProgram } from './utility'\r\n\r\nclass BrickWallModel {\r\n  constructor(gl) {\r\n    this.gl = gl;\r\n    this.draw = this.draw.bind(this);\r\n    const shaderProgram = this._initShaders(gl);\r\n    this.model = {\r\n      shader: {\r\n        program: shaderProgram,\r\n        attribLocations: {\r\n          vertexPosition: gl.getAttribLocation(shaderProgram, 'vert_pos'),\r\n          vertexTangent: gl.getAttribLocation(shaderProgram, 'vert_tang'),\r\n          vertexBitangent: gl.getAttribLocation(shaderProgram, 'vert_bitang'),\r\n          textureCoord: gl.getAttribLocation(shaderProgram, 'vert_uv')\r\n        },\r\n        uniformLocations: {\r\n          modelMatrix: gl.getUniformLocation(shaderProgram, 'model_mtx'),\r\n          viewMatrix: gl.getUniformLocation(shaderProgram, 'view_mtx'),\r\n          normalMatrix: gl.getUniformLocation(shaderProgram, 'norm_mtx'),\r\n          projectionMatrix: gl.getUniformLocation(shaderProgram, 'proj_mtx'),\r\n          textureNormal: gl.getUniformLocation(shaderProgram, 'tex_norm'),\r\n          textureDiffuse: gl.getUniformLocation(shaderProgram, 'tex_diffuse'),\r\n          showTexture: gl.getUniformLocation(shaderProgram, 'show_texture'),\r\n          cameraPosition: gl.getUniformLocation(shaderProgram, 'camera_pos'),\r\n          ambientLight: gl.getUniformLocation(shaderProgram, 'ambient_color'),\r\n          directionalLight: {\r\n            direction: gl.getUniformLocation(shaderProgram, 'diffuse_dir'),\r\n            color: gl.getUniformLocation(shaderProgram, 'diffuse_color')\r\n          },\r\n          pointLight: {\r\n            position: gl.getUniformLocation(shaderProgram, 'point_pos'),\r\n            color: gl.getUniformLocation(shaderProgram, 'point_color')\r\n          }\r\n        }\r\n      },\r\n      buffers: this._initBuffers(gl),\r\n      texture: {\r\n        diffuse: loadTexture(gl, 'images/Brick_Wall_017_basecolor.jpg'),\r\n        normal: loadTexture(gl, 'images/Brick_Wall_017_normal.jpg')\r\n      }\r\n    }\r\n  }\r\n\r\n  draw(projectionMatrix, viewMatrix, modelMatrix) {\r\n    const gl = this.gl;\r\n    const { buffers, texture } = this.model;\r\n\r\n    const shader = this.model.shader;\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(shader.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(shader.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.tangent);\r\n      gl.vertexAttribPointer(shader.attribLocations.vertexTangent, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(shader.attribLocations.vertexTangent);\r\n    }\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.bitangent);\r\n      gl.vertexAttribPointer(shader.attribLocations.vertexBitangent, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(shader.attribLocations.vertexBitangent);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(shader.attribLocations.textureCoord, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(shader.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    const normalMatrix = mat4.create();\r\n    mat4.invert(normalMatrix, modelMatrix);\r\n    mat4.transpose(normalMatrix, normalMatrix);\r\n\r\n    gl.useProgram(shader.program);\r\n    gl.uniformMatrix4fv(shader.uniformLocations.projectionMatrix, false, projectionMatrix);\r\n    gl.uniformMatrix4fv(shader.uniformLocations.modelMatrix, false, modelMatrix);\r\n    gl.uniformMatrix4fv(shader.uniformLocations.viewMatrix, false, viewMatrix);\r\n    gl.uniformMatrix4fv(shader.uniformLocations.normalMatrix, false, normalMatrix);\r\n\r\n    gl.uniform1i(shader.uniformLocations.showTexture, 1);\r\n\r\n    gl.uniform3f(shader.uniformLocations.ambientLight, 0.2, 0.2, 0.2);\r\n\r\n    const direction = vec3.fromValues(0.0, 1.0, 0.0);\r\n    vec3.normalize(direction, direction);\r\n    gl.uniform3f(shader.uniformLocations.directionalLight.color, 1.0, 1.0, 1.0);\r\n    gl.uniform3fv(shader.uniformLocations.directionalLight.direction, direction);\r\n\r\n    gl.uniform3f(shader.uniformLocations.pointLight.color, 1.0, 1.0, 1.0);\r\n    gl.uniform3f(shader.uniformLocations.pointLight.position, 0.0, 0.0, 0.0);\r\n\r\n    gl.uniform3f(shader.uniformLocations.cameraPosition, 0.0, 0.0, 0.0);\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture.normal);\r\n      gl.uniform1i(shader.uniformLocations.textureNormal, 0);\r\n\r\n      gl.activeTexture(gl.TEXTURE1);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture.diffuse);\r\n      gl.uniform1i(shader.uniformLocations.textureDiffuse, 1);\r\n\r\n      const vertexCount = buffers.vertexCount;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n  }\r\n\r\n  _initShaders(gl) {\r\n    const vsSource = `\r\n      precision highp float;\r\n\r\n      attribute vec3 vert_pos;\r\n      attribute vec3 vert_tang;\r\n      attribute vec3 vert_bitang;\r\n      attribute vec2 vert_uv;\r\n      \r\n      uniform vec3 camera_pos;\r\n      uniform vec3 point_pos;\r\n      uniform vec3 diffuse_dir;\r\n      uniform mat4 norm_mtx;\r\n      uniform mat4 model_mtx;\r\n      uniform mat4 view_mtx;\r\n      uniform mat4 proj_mtx;\r\n      \r\n      varying vec2 frag_uv;\r\n      varying vec3 ts_light_pos;\r\n      varying vec3 ts_view_pos;\r\n      varying vec3 ts_frag_pos;\r\n      varying vec3 ts_diffuse_dir;\r\n      \r\n      mat3 transpose(in mat3 inMatrix)\r\n      {\r\n          vec3 i0 = inMatrix[0];\r\n          vec3 i1 = inMatrix[1];\r\n          vec3 i2 = inMatrix[2];\r\n      \r\n          mat3 outMatrix = mat3(\r\n              vec3(i0.x, i1.x, i2.x),\r\n              vec3(i0.y, i1.y, i2.y),\r\n              vec3(i0.z, i1.z, i2.z)\r\n          );\r\n      \r\n          return outMatrix;\r\n      }\r\n      \r\n      void main(void)\r\n      {\r\n          frag_uv = vert_uv;\r\n\r\n          vec3 t = normalize(mat3(norm_mtx) * vert_tang);\r\n          vec3 b = normalize(mat3(norm_mtx) * vert_bitang);\r\n          mat3 tbn = transpose(mat3(t, b, normalize(mat3(norm_mtx) * cross(vert_bitang, vert_tang))));\r\n      \r\n          ts_light_pos = tbn * point_pos;\r\n          ts_view_pos = tbn * camera_pos;\r\n          ts_frag_pos = tbn * vec3(model_mtx * vec4(vert_pos, 1.0));\r\n          ts_diffuse_dir = tbn * diffuse_dir;\r\n\r\n          gl_Position = proj_mtx * view_mtx * model_mtx * vec4(vert_pos, 1.0);\r\n      } \r\n    `;\r\n\r\n    const fsSource = `\r\n      precision highp float;\r\n\r\n      uniform sampler2D tex_norm;\r\n      uniform sampler2D tex_diffuse;\r\n      uniform int show_texture;\r\n      uniform vec3 ambient_color;\r\n      uniform vec3 diffuse_color;\r\n      uniform vec3 point_color;\r\n      \r\n      varying vec2 frag_uv;\r\n      varying vec3 ts_light_pos;\r\n      varying vec3 ts_view_pos;\r\n      varying vec3 ts_frag_pos;\r\n      varying vec3 ts_diffuse_dir;\r\n      \r\n      void main(void)\r\n      {\r\n        vec3 view_dir = normalize(ts_view_pos - ts_frag_pos);\r\n      \r\n        vec3 albedo = texture2D(tex_diffuse, frag_uv).rgb;\r\n\r\n        if (show_texture == 0) {\r\n          albedo = vec3(1.0, 1.0, 1.0);\r\n        }\r\n      \r\n        float point_intensity;\r\n        float diffuse_intensity;\r\n\r\n        vec3 norm = normalize(texture2D(tex_norm, frag_uv).rgb * 2.0 - 1.0);\r\n        vec3 light_dir = ts_light_pos - ts_frag_pos;\r\n        point_intensity = 15.0 * max(dot(norm, normalize(light_dir)), 0.0) / (length(light_dir) * length(light_dir));\r\n        point_intensity = clamp(point_intensity, 0.0, 1.0);\r\n        diffuse_intensity = max(dot(ts_diffuse_dir, norm), 0.0);\r\n\r\n        vec3 lighting = ambient_color + (diffuse_color * diffuse_intensity) + (point_color * point_intensity); \r\n        gl_FragColor = vec4(albedo * lighting, 1.0);\r\n      }\r\n    `;\r\n\r\n    return initShaderProgram(gl, vsSource, fsSource);\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [];\r\n    const tangents = [];\r\n    const bitangents = [];\r\n    const textureCoordinates = [];\r\n    const indices = [];\r\n    const tangent = vec3.create();\r\n    const bitangent = vec3.create();\r\n    let offset = 0;\r\n\r\n    const addSquare = (c0, c1, c2, c3) => {\r\n      positions.push(...c0, ...c1, ...c2, ...c3);\r\n      vec3.subtract(tangent, c3, c0);\r\n      vec3.normalize(tangent, tangent);\r\n      tangents.push(...tangent, ...tangent, ...tangent, ...tangent);\r\n      vec3.subtract(bitangent, c0, c2);\r\n      vec3.normalize(bitangent, bitangent);\r\n      bitangents.push(...bitangent, ...bitangent, ...bitangent, ...bitangent);\r\n      textureCoordinates.push(0, 0, 1, 1, 0, 1, 1, 0);\r\n      indices.push(offset + 0, offset + 1, offset + 2, offset + 0, offset + 3, offset + 1);\r\n      offset += 4;\r\n    }\r\n\r\n    const f0 = vec3.fromValues(-1, -1, 1);\r\n    const f1 = vec3.fromValues(1, 1, 1);\r\n    const f2 = vec3.fromValues(-1, 1, 1);\r\n    const f3 = vec3.fromValues(1, -1, 1);\r\n    const b0 = vec3.fromValues(-1, -1, -1);\r\n    const b1 = vec3.fromValues(1, 1, -1);\r\n    const b2 = vec3.fromValues(-1, 1, -1);\r\n    const b3 = vec3.fromValues(1, -1, -1);\r\n    addSquare(f0, f1, f2, f3);  // front\r\n    addSquare(b3, b2, b1, b0);  // back\r\n    addSquare(b0, f2, b2, f0);  // left\r\n    addSquare(f3, b1, f1, b3);  // right\r\n    addSquare(b0, f3, f0, b3);  // bottom\r\n    addSquare(b1, f2, f1, b2);  // top\r\n\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const tangentBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, tangentBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tangents), gl.STATIC_DRAW);\r\n\r\n    const bitangentBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, bitangentBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bitangents), gl.STATIC_DRAW);\r\n\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, tangent: tangentBuffer, bitangent: bitangentBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer, vertexCount: indices.length };\r\n  }\r\n}\r\n\r\nexport default BrickWallModel;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { clearScreen } from './utility'\r\nimport BrickWallModel from './BrickWallModel';\r\n\r\nclass BrickWallScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const model = new BrickWallModel(gl);\r\n    this.scene = {\r\n      actors: [\r\n        {\r\n          model,\r\n          location: [0.0, 0.0, -5.5],\r\n          rotations: [\r\n            {\r\n              angle: 0.0,\r\n              axis: [0, 1, 0],\r\n              speed: 0.4\r\n            },\r\n            {\r\n              angle: 0.0,\r\n              axis: [1, 0, 0],\r\n              speed: 0.2\r\n            }\r\n          ]\r\n        }\r\n      ],\r\n      camera: [0.0, 0.0, 0.0]\r\n    };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    const fieldOfView = 45 * Math.PI / 180;\r\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n    const zNear = 0.1;\r\n    const zFar = 100.0;\r\n    const projectionMatrix = mat4.create();\r\n    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n\r\n    const viewMatrix = mat4.create();\r\n    mat4.translate(viewMatrix, viewMatrix, scene.camera);\r\n    mat4.invert(viewMatrix, viewMatrix)\r\n\r\n    for (let i = 0; i < scene.actors.length; i++) {\r\n      const actor = scene.actors[i];\r\n      this._renderActor(projectionMatrix, viewMatrix, actor);\r\n      this._animateActor(deltaTime, actor);\r\n    }\r\n  }\r\n\r\n  _renderActor(projectionMatrix, viewMatrix, actor) {\r\n    const model = actor.model;\r\n\r\n    const modelMatrix = mat4.create();\r\n    mat4.translate(modelMatrix, modelMatrix, actor.location);\r\n    for (let i = 0; i < actor.rotations.length; i++) {\r\n      const rotation = actor.rotations[i];\r\n      mat4.rotate(modelMatrix, modelMatrix, rotation.angle, rotation.axis);\r\n    }\r\n\r\n    model.draw(projectionMatrix, viewMatrix, modelMatrix);\r\n  }\r\n\r\n  _animateActor(deltaTime, actor) {\r\n    for (let i = 0; i < actor.rotations.length; i++) {\r\n      const rotation = actor.rotations[i];\r\n      rotation.angle += deltaTime * rotation.speed;\r\n    }\r\n  }\r\n}\r\n\r\nexport default BrickWallScene;\r\n","import React from 'react';\r\nimport ColoredSquareScene from './ColoredSquareScene';\r\nimport ColoredCubeScene from './ColoredCubeScene';\r\nimport TexturedCubeScene from './TexturedCubeScene';\r\nimport LightedCubeScene from './LightedCubeScene';\r\nimport MazeScene from './MazeScene';\r\nimport BrickWallScene from './BrickWallScene';\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.onClickCanvas = this.onClickCanvas.bind(this);\r\n    this.renderCanvas = this.renderCanvas.bind(this);\r\n    this.scenes = [\r\n      { init: false, render: new ColoredSquareScene() },\r\n      { init: false, render: new ColoredCubeScene() },\r\n      { init: false, render: new TexturedCubeScene() },\r\n      { init: false, render: new LightedCubeScene() },\r\n      { init: false, render: new MazeScene() },\r\n      { init: false, render: new BrickWallScene() }\r\n    ];\r\n    this.sceneIndex = this.scenes.length - 1;\r\n  }\r\n\r\n  componentDidMount() {\r\n    const canvas = this.canvas;\r\n    const rect = canvas.getBoundingClientRect()\r\n    canvas.width = rect.width;\r\n    canvas.height = rect.height;\r\n    this.gl = canvas.getContext('webgl');\r\n    if (this.gl === null) {\r\n      alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n    } else {\r\n      this.gl.enable(this.gl.CULL_FACE);\r\n      this.gl.cullFace(this.gl.BACK);\r\n      this.gl.getExtension('OES_element_index_uint');\r\n      const scene = this.scenes[this.sceneIndex];\r\n      if (!scene.init) {\r\n        scene.init = true;\r\n        scene.render.initScene(this.gl);\r\n      }\r\n      this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.cancelAnimationFrame(this.frame);\r\n  }\r\n\r\n  onClickCanvas(event) {\r\n    event.preventDefault();\r\n    this.sceneIndex = (this.sceneIndex + 1) % this.scenes.length;\r\n    const scene = this.scenes[this.sceneIndex];\r\n    if (!scene.init) {\r\n      scene.init = true;\r\n      scene.render.initScene(this.gl);\r\n    }\r\n  }\r\n\r\n  renderCanvas(timeStamp) {\r\n    timeStamp *= 0.001;\r\n    if (!this.timeStamp) {\r\n      this.timeStamp = timeStamp;\r\n    }\r\n    const deltaTime = timeStamp - this.timeStamp;\r\n    this.timeStamp = timeStamp;\r\n    const scene = this.scenes[this.sceneIndex];\r\n    scene.render.drawScene(this.gl, deltaTime);\r\n    this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"screen\">\r\n        <canvas className=\"canvas\" ref={elem => this.canvas = elem} onClick={this.onClickCanvas}></canvas>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}