{"version":3,"sources":["utility.js","ColoredSquareScene.js","ColoredCubeScene.js","TexturedCubeScene.js","LightedCubeModel.js","LightedCubeScene.js","MazeModel.js","MazeScene.js","App.js","serviceWorker.js","index.js"],"names":["initShaderProgram","gl","vsSource","fsSource","vertexShader","_loadShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","alert","getProgramInfoLog","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","loadTexture","url","texture","createTexture","bindTexture","TEXTURE_2D","internalFormat","RGBA","srcFormat","srcType","UNSIGNED_BYTE","pixel","Uint8Array","texImage2D","image","Image","onload","_isPowerOf2","width","height","generateMipmap","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","src","value","clearScreen","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","_directions","x","y","ColoredSquareScene","this","initScene","bind","drawScene","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexColor","uniformLocations","projectionMatrix","getUniformLocation","modelViewMatrix","buffers","_initBuffers","scene","squareRotation","deltaTime","FLOAT","bindBuffer","ARRAY_BUFFER","color","vertexAttribPointer","enableVertexAttribArray","position","fieldOfView","Math","PI","aspect","canvas","clientWidth","clientHeight","mat4","useProgram","uniformMatrix4fv","drawArrays","TRIANGLE_STRIP","createBuffer","bufferData","Float32Array","STATIC_DRAW","ColoredCubeScene","cubeRotation","ELEMENT_ARRAY_BUFFER","indices","UNSIGNED_SHORT","drawElements","TRIANGLES","positionBuffer","faceColors","colors","j","length","c","concat","colorBuffer","indexBuffer","Uint16Array","TexturedCubeScene","textureCoord","uSampler","activeTexture","TEXTURE0","uniform1i","textureCoordBuffer","LightedCubeModel","draw","_initShaders","model","vertexNormal","normalMatrix","viewMatrix","modelMatrix","normal","normalBuffer","LightedCubeScene","actors","location","rotation","rotationSpeed","camera","cameraDir","i","actor","_renderActor","_animateActor","MazeModel","maze","vertexCount","wallColor","floorColor","positions","ofs_x","ofs_y","left","right","top","bottom","push","data","offset","MazeScene","windiness","carve","pos","canCarve","dir","isInBounds","addDir","nxt","len","Array","fill","lastDir","start","cells","cell","posCells","includes","random","floor","pop","generateMaze","angle","axis","speed","App","props","onClickCanvas","renderCanvas","scenes","init","render","sceneIndex","rect","getBoundingClientRect","getContext","frame","window","requestAnimationFrame","cancelAnimationFrame","event","preventDefault","timeStamp","className","ref","elem","onClick","React","Component","Boolean","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.de659017.chunk.js","sourcesContent":["export function degreesToRadians(degrees) {\r\n  var pi = Math.PI;\r\n  return degrees * (pi / 180);\r\n}\r\n\r\nexport function initShaderProgram(gl, vsSource, fsSource) {\r\n  const vertexShader = _loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n  const fragmentShader = _loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n  const shaderProgram = gl.createProgram();\r\n  gl.attachShader(shaderProgram, vertexShader);\r\n  gl.attachShader(shaderProgram, fragmentShader);\r\n  gl.linkProgram(shaderProgram);\r\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n    return null;\r\n  }\r\n  return shaderProgram;\r\n}\r\n\r\nfunction _loadShader(gl, type, source) {\r\n  const shader = gl.createShader(type);\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n    return null;\r\n  }\r\n  return shader;\r\n}\r\n\r\nexport function loadTexture(gl, url) {\r\n  const texture = gl.createTexture();\r\n  gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  const level = 0;\r\n  const internalFormat = gl.RGBA;\r\n  const width = 1;\r\n  const height = 1;\r\n  const border = 0;\r\n  const srcFormat = gl.RGBA;\r\n  const srcType = gl.UNSIGNED_BYTE;\r\n  const pixel = new Uint8Array([0, 0, 255, 255]);\r\n  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);\r\n  const image = new Image();\r\n  image.onload = () => {\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\r\n      srcFormat, srcType, image);\r\n    if (_isPowerOf2(image.width) && _isPowerOf2(image.height)) {\r\n      gl.generateMipmap(gl.TEXTURE_2D);\r\n    } else {\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    }\r\n  };\r\n  image.src = url;\r\n  return texture;\r\n}\r\n\r\nfunction _isPowerOf2(value) {\r\n  return (value & (value - 1)) === 0;\r\n}\r\n\r\nexport function clearScreen(gl) {\r\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n  gl.clearDepth(1.0);\r\n  gl.enable(gl.DEPTH_TEST);\r\n  gl.depthFunc(gl.LEQUAL);\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n}\r\n\r\nconst _directions = [\r\n  { x: -1, y: 0 },\r\n  { x: 0, y: -1 },\r\n  { x: 1, y: 0 },\r\n  { x: 0, y: 1 }\r\n];\r\n\r\nexport function generateMaze(width, height, windiness = 0.8) {\r\n  const carve = (pos) => {\r\n    data[pos.y][pos.x] = 0;\r\n  }\r\n\r\n  const canCarve = (pos, dir) => {\r\n    if (!isInBounds(addDir(pos, dir, 3))) {\r\n      return false;\r\n    }\r\n    const nxt = addDir(pos, dir, 2);\r\n    return data[nxt.y][nxt.x] === 1;\r\n  }\r\n\r\n  const isInBounds = (pos) => {\r\n    if (pos.x < 0 || pos.y < 0 || pos.x >= width || pos.y >= height) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  const addDir = (pos, dir, len) => {\r\n    return {\r\n      x: pos.x + dir.x * len,\r\n      y: pos.y + dir.y * len\r\n    }\r\n  }\r\n\r\n  const data = [];\r\n  for (let y = 0; y < height; y++) {\r\n    data.push(new Array(width).fill(1));\r\n  }\r\n\r\n  const start = { x: 1, y: 1 };\r\n  const cells = [];\r\n  let lastDir;\r\n  carve(start);\r\n  cells.push(start);\r\n  while (cells.length > 0) {\r\n    const cell = cells[cells.length - 1];\r\n    const posCells = [];\r\n    for (let i = 0; i < _directions.length; i++) {\r\n      const dir = _directions[i];\r\n      if (canCarve(cell, dir)) {\r\n        posCells.push(dir);\r\n      }\r\n    }\r\n    if (posCells.length > 0) {\r\n      let dir;\r\n      if (posCells.includes(lastDir) && Math.random() > windiness) {\r\n        dir = lastDir;\r\n      } else {\r\n        dir = posCells[Math.floor(Math.random() * posCells.length)];\r\n      }\r\n      carve(addDir(cell, dir, 1));\r\n      carve(addDir(cell, dir, 2));\r\n      cells.push(addDir(cell, dir, 2));\r\n      lastDir = dir;\r\n    } else {\r\n      cells.pop();\r\n      lastDir = null;\r\n    }\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    data\r\n  };\r\n}\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, clearScreen } from './utility'\r\n\r\nclass ColoredSquareScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, squareRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.squareRotation, [0, 0, 1]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const offset = 0;\r\n      const vertexCount = 4;\r\n      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\r\n    }\r\n\r\n    scene.squareRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      1.0, 1.0,\r\n      -1.0, 1.0,\r\n      1.0, -1.0,\r\n      -1.0, -1.0,\r\n    ];\r\n    const position = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, position);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const colors = [\r\n      1.0, 1.0, 1.0, 1.0,\r\n      1.0, 0.0, 0.0, 1.0,\r\n      0.0, 1.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0, 1.0\r\n    ];\r\n    const color = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, color);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    return { position, color };\r\n  }\r\n}\r\n\r\nexport default ColoredSquareScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, clearScreen } from './utility'\r\n\r\nclass ColoredCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const faceColors = [\r\n      [1.0, 1.0, 1.0, 1.0],    // Front face: white\r\n      [1.0, 0.0, 0.0, 1.0],    // Back face: red\r\n      [0.0, 1.0, 0.0, 1.0],    // Top face: green\r\n      [0.0, 0.0, 1.0, 1.0],    // Bottom face: blue\r\n      [1.0, 1.0, 0.0, 1.0],    // Right face: yellow\r\n      [1.0, 0.0, 1.0, 1.0],    // Left face: purple\r\n    ];\r\n    let colors = [];\r\n    for (let j = 0; j < faceColors.length; ++j) {\r\n      const c = faceColors[j];\r\n      colors = colors.concat(c, c, c, c);\r\n    }\r\n    const colorBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, color: colorBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default ColoredCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, loadTexture, clearScreen } from './utility'\r\n\r\nclass TexturedCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec2 aTextureCoord;\r\n\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying highp vec2 vTextureCoord;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying highp vec2 vTextureCoord;\r\n\r\n      uniform sampler2D uSampler;\r\n\r\n      void main(void) {\r\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n      }\r\n    `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n        uSampler: gl.getUniformLocation(shaderProgram, 'uSampler')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    const texture = loadTexture(gl, 'images/cubetexture.png');\r\n\r\n    this.scene = { programInfo, buffers, texture, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers, texture } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.textureCoord,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.uniform1i(programInfo.uniformLocations.uSampler, 0);\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const textureCoordinates = [\r\n      // Front\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Back\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Top\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Bottom\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Right\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Left\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n    ];\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default TexturedCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { loadTexture, initShaderProgram } from './utility'\r\n\r\nclass LightedCubeModel {\r\n  constructor(gl) {\r\n    this.gl = gl;\r\n    this.draw = this.draw.bind(this);\r\n    const shaderProgram = this._initShaders(gl);\r\n    this.model = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),\r\n        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n        normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),\r\n        uSampler: gl.getUniformLocation(shaderProgram, 'uSampler')\r\n      },\r\n      buffers: this._initBuffers(gl),\r\n      texture: loadTexture(gl, 'images/cubetexture.png')\r\n    }\r\n  }\r\n\r\n  draw(projectionMatrix, viewMatrix, modelMatrix) {\r\n    const gl = this.gl;\r\n    const model = this.model;\r\n    const { buffers, texture } = this.model;\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(model.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);\r\n      gl.vertexAttribPointer(model.attribLocations.vertexNormal, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.vertexNormal);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(model.attribLocations.textureCoord, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    const normalMatrix = mat4.create();\r\n    mat4.invert(normalMatrix, modelMatrix);\r\n    mat4.transpose(normalMatrix, normalMatrix);\r\n\r\n    const modelViewMatrix = mat4.create();\r\n    mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);\r\n\r\n    gl.useProgram(model.program);\r\n    gl.uniformMatrix4fv(model.uniformLocations.projectionMatrix, false, projectionMatrix);\r\n    gl.uniformMatrix4fv(model.uniformLocations.modelViewMatrix, false, modelViewMatrix);\r\n    gl.uniformMatrix4fv(model.uniformLocations.normalMatrix, false, normalMatrix);\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.uniform1i(model.uniformLocations.uSampler, 0);\r\n\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n  }\r\n\r\n  _initShaders(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec3 aVertexNormal;\r\n      attribute vec2 aTextureCoord;\r\n\r\n      uniform mat4 uNormalMatrix;\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying highp vec2 vTextureCoord;\r\n      varying highp vec3 vLighting;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n\r\n        // Apply lighting effect\r\n\r\n        highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);\r\n        highp vec3 directionalLightColor = vec3(1, 1, 1);\r\n        highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\r\n\r\n        highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);\r\n\r\n        highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\r\n        vLighting = ambientLight + (directionalLightColor * directional);\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying highp vec2 vTextureCoord;\r\n      varying highp vec3 vLighting;\r\n\r\n      uniform sampler2D uSampler;\r\n\r\n      void main(void) {\r\n        highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\r\n\r\n        gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\r\n      }\r\n    `;\r\n\r\n    return initShaderProgram(gl, vsSource, fsSource);\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const vertexNormals = [\r\n      // Front\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n\r\n      // Back\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n\r\n      // Top\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n\r\n      // Bottom\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n\r\n      // Right\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n\r\n      // Left\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0\r\n    ];\r\n\r\n    const normalBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);\r\n\r\n    const textureCoordinates = [\r\n      // Front\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Back\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Top\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Bottom\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Right\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Left\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n    ];\r\n\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      // Front\r\n      0, 1, 2, 0, 2, 3,\r\n\r\n      // Back\r\n      4, 5, 6, 4, 6, 7,\r\n\r\n      // Top\r\n      8, 9, 10, 8, 10, 11,\r\n\r\n      // Bottom\r\n      12, 13, 14, 12, 14, 15,\r\n\r\n      // Right\r\n      16, 17, 18, 16, 18, 19,\r\n\r\n      // Left\r\n      20, 21, 22, 20, 22, 23,\r\n    ];\r\n\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, normal: normalBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default LightedCubeModel;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { clearScreen } from './utility'\r\nimport LightedCubeModel from './LightedCubeModel';\r\n\r\nclass LightedCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const model = new LightedCubeModel(gl);\r\n    this.scene = {\r\n      actors: [\r\n        {\r\n          model,\r\n          location: [-2.0, 0.0, -5.5],\r\n          rotation: 0.0,\r\n          rotationSpeed: 1.0\r\n        },\r\n        {\r\n          model,\r\n          location: [2.0, 0.0, -5.5],\r\n          rotation: 0.0,\r\n          rotationSpeed: 2.0\r\n        }\r\n      ],\r\n      camera: [0.0, 0.0, 0.0],\r\n      cameraDir: [0.0, 0.0, 8.0]\r\n    };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    const fieldOfView = 45 * Math.PI / 180;\r\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n    const zNear = 0.1;\r\n    const zFar = 100.0;\r\n    const projectionMatrix = mat4.create();\r\n    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n\r\n    const viewMatrix = mat4.create();\r\n    mat4.translate(viewMatrix, viewMatrix, scene.camera);\r\n    mat4.invert(viewMatrix, viewMatrix)\r\n\r\n    for (let i = 0; i < scene.actors.length; i++) {\r\n      const actor = scene.actors[i];\r\n      this._renderActor(projectionMatrix, viewMatrix, actor);\r\n      this._animateActor(deltaTime, actor);\r\n    }\r\n\r\n    if (scene.camera[2] > 64.0) {\r\n      scene.camera[2] = 64.0;\r\n      scene.cameraDir[2] = -8.0;\r\n    } else if (scene.camera[2] < 0.0) {\r\n      scene.camera[2] = 0.0;\r\n      scene.cameraDir[2] = 8.0;\r\n    }\r\n\r\n    scene.camera[0] += scene.cameraDir[0] * deltaTime;\r\n    scene.camera[1] += scene.cameraDir[1] * deltaTime;\r\n    scene.camera[2] += scene.cameraDir[2] * deltaTime;\r\n  }\r\n\r\n  _renderActor(projectionMatrix, viewMatrix, actor) {\r\n    const model = actor.model;\r\n\r\n    const modelMatrix = mat4.create();\r\n    mat4.translate(modelMatrix, modelMatrix, actor.location);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation, [0, 0, 1]);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation * 0.7, [0, 1, 0]);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation * 0.3, [1, 0, 0]);\r\n\r\n    model.draw(projectionMatrix, viewMatrix, modelMatrix);\r\n  }\r\n\r\n  _animateActor(deltaTime, actor) {\r\n    actor.rotation += deltaTime * actor.rotationSpeed;\r\n  }\r\n}\r\n\r\nexport default LightedCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram } from './utility'\r\n\r\nclass MazeModel {\r\n  constructor(gl, maze) {\r\n    this.gl = gl;\r\n    this.maze = maze;\r\n    this.draw = this.draw.bind(this);\r\n    const shaderProgram = this._initShaders(gl);\r\n    this.model = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      },\r\n      buffers: this._initBuffers(gl, maze),\r\n    }\r\n  }\r\n\r\n  draw(projectionMatrix, viewMatrix, modelMatrix) {\r\n    const gl = this.gl;\r\n    const model = this.model;\r\n    const { buffers } = this.model;\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(model.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(model.attribLocations.vertexColor, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.vertexColor);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    const modelViewMatrix = mat4.create();\r\n    mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);\r\n\r\n    gl.useProgram(model.program);\r\n    gl.uniformMatrix4fv(model.uniformLocations.projectionMatrix, false, projectionMatrix);\r\n    gl.uniformMatrix4fv(model.uniformLocations.modelViewMatrix, false, modelViewMatrix);\r\n\r\n    {\r\n      const vertexCount = this.maze.width * this.maze.height * 6;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n  }\r\n\r\n  _initShaders(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec4 aVertexColor;\r\n\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying lowp vec4 vColor;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vColor = aVertexColor;\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying lowp vec4 vColor;\r\n\r\n      void main(void) {\r\n        gl_FragColor = vColor;\r\n      }\r\n    `;\r\n\r\n    return initShaderProgram(gl, vsSource, fsSource);\r\n  }\r\n\r\n  _initBuffers(gl, maze) {\r\n    const wallColor = [.65, .65, .65, 1];\r\n    const floorColor = [.1, .1, .1, 1.0];\r\n\r\n    const positions = []\r\n    const colors = [];\r\n    const indices = [];\r\n    const ofs_x = -maze.width / 2;\r\n    const ofs_y = -maze.height / 2;\r\n    for (let y = 0; y < maze.height; y++) {\r\n      for (let x = 0; x < maze.width; x++) {\r\n        const left = x + ofs_x;\r\n        const right = left + 1;\r\n        const top = y + ofs_y;\r\n        const bottom = top + 1;\r\n        positions.push(left, top, right, top, right, bottom, left, bottom);\r\n        let color;\r\n        if (maze.data[y][x] === 0) {\r\n          color = floorColor;\r\n        } else {\r\n          color = wallColor;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n          for (let j = 0; j < 4; j++) {\r\n            colors.push(color[j]);\r\n          }\r\n        }\r\n        const offset = (y * maze.height + x) * 4;\r\n        indices.push(offset + 0, offset + 1, offset + 2, offset + 0, offset + 2, offset + 3);\r\n      }\r\n    }\r\n\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const colorBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, color: colorBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default MazeModel;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { clearScreen, degreesToRadians, generateMaze } from './utility'\r\nimport MazeModel from './MazeModel';\r\n\r\nclass MazeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const size = 39;\r\n    const maze = generateMaze(size, size);\r\n    const model = new MazeModel(gl, maze);\r\n    this.scene = {\r\n      actors: [\r\n        {\r\n          model,\r\n          location: [0.0, 0.0, -2.0 * size],\r\n          rotation: { angle: 0.0, axis: [0, 0, 1], speed: 0.5 }\r\n        }\r\n      ],\r\n      camera: [0.0, 0.0, 0.0],\r\n      cameraDir: [0.0, 0.0, 8.0]\r\n    };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    const fieldOfView = 45 * Math.PI / 180;\r\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n    const zNear = 0.1;\r\n    const zFar = 100.0;\r\n    const projectionMatrix = mat4.create();\r\n    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n\r\n    const viewMatrix = mat4.create();\r\n    mat4.translate(viewMatrix, viewMatrix, scene.camera);\r\n    mat4.invert(viewMatrix, viewMatrix)\r\n\r\n    for (let i = 0; i < scene.actors.length; i++) {\r\n      const actor = scene.actors[i];\r\n      this._renderActor(projectionMatrix, viewMatrix, actor);\r\n      this._animateActor(deltaTime, actor);\r\n    }\r\n  }\r\n\r\n  _renderActor(projectionMatrix, viewMatrix, actor) {\r\n    const model = actor.model;\r\n\r\n    const modelMatrix = mat4.create();\r\n    mat4.translate(modelMatrix, modelMatrix, actor.location);\r\n    mat4.rotate(modelMatrix, modelMatrix, degreesToRadians(-45), [1, 0, 0]);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation.angle, actor.rotation.axis);\r\n\r\n    model.draw(projectionMatrix, viewMatrix, modelMatrix);\r\n  }\r\n\r\n  _animateActor(deltaTime, actor) {\r\n    actor.rotation.angle += deltaTime * actor.rotation.speed;\r\n  }\r\n}\r\n\r\nexport default MazeScene;\r\n","import React from 'react';\r\nimport ColoredSquareScene from './ColoredSquareScene';\r\nimport ColoredCubeScene from './ColoredCubeScene';\r\nimport TexturedCubeScene from './TexturedCubeScene';\r\nimport LightedCubeScene from './LightedCubeScene';\r\nimport MazeScene from './MazeScene';\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.onClickCanvas = this.onClickCanvas.bind(this);\r\n    this.renderCanvas = this.renderCanvas.bind(this);\r\n    this.scenes = [\r\n      { init: false, render: new ColoredSquareScene() },\r\n      { init: false, render: new ColoredCubeScene() },\r\n      { init: false, render: new TexturedCubeScene() },\r\n      { init: false, render: new LightedCubeScene() },\r\n      { init: false, render: new MazeScene() }\r\n    ];\r\n    this.sceneIndex = this.scenes.length - 1;\r\n  }\r\n\r\n  componentDidMount() {\r\n    const canvas = this.canvas;\r\n    const rect = canvas.getBoundingClientRect()\r\n    canvas.width = rect.width;\r\n    canvas.height = rect.height;\r\n    this.gl = canvas.getContext('webgl');\r\n    if (this.gl === null) {\r\n      alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n    } else {\r\n      const scene = this.scenes[this.sceneIndex];\r\n      if (!scene.init) {\r\n        scene.init = true;\r\n        scene.render.initScene(this.gl);\r\n      }\r\n      this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.cancelAnimationFrame(this.frame);\r\n  }\r\n\r\n  onClickCanvas(event) {\r\n    event.preventDefault();\r\n    this.sceneIndex = (this.sceneIndex + 1) % this.scenes.length;\r\n    const scene = this.scenes[this.sceneIndex];\r\n    if (!scene.init) {\r\n      scene.init = true;\r\n      scene.render.initScene(this.gl);\r\n    }\r\n  }\r\n\r\n  renderCanvas(timeStamp) {\r\n    if (!this.timeStamp) {\r\n      this.timeStamp = timeStamp;\r\n    }\r\n    timeStamp *= 0.001;\r\n    const deltaTime = timeStamp - this.timeStamp;\r\n    this.timeStamp = timeStamp;\r\n    const scene = this.scenes[this.sceneIndex];\r\n    scene.render.drawScene(this.gl, deltaTime);\r\n    this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"screen\">\r\n        <canvas className=\"canvas\" ref={elem => this.canvas = elem} onClick={this.onClickCanvas}></canvas>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}