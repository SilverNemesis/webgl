{"version":3,"sources":["ColoredSquareScene.js","App.js","serviceWorker.js","index.js"],"names":["ColoredSquareScene","this","initScene","bind","drawScene","gl","shaderProgram","_initShaderProgram","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexColor","uniformLocations","projectionMatrix","getUniformLocation","modelViewMatrix","buffers","_initBuffers","scene","squareRotation","deltaTime","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","type","FLOAT","bindBuffer","ARRAY_BUFFER","color","vertexAttribPointer","enableVertexAttribArray","position","fieldOfView","Math","PI","aspect","canvas","clientWidth","clientHeight","mat4","useProgram","uniformMatrix4fv","drawArrays","TRIANGLE_STRIP","vsSource","fsSource","vertexShader","_loadShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","alert","getProgramInfoLog","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","createBuffer","bufferData","Float32Array","STATIC_DRAW","App","props","renderCanvas","rect","getBoundingClientRect","width","height","getContext","frame","window","requestAnimationFrame","cancelAnimationFrame","timeStamp","className","ref","elem","React","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cd9ea68c.chunk.js","sourcesContent":["import * as mat4 from 'gl-matrix/mat4';\r\n\r\nclass ColoredSquareScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = this._initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, squareRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.depthFunc(gl.LEQUAL);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.squareRotation, [0, 0, 1]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const offset = 0;\r\n      const vertexCount = 4;\r\n      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\r\n    }\r\n\r\n    scene.squareRotation += deltaTime;\r\n  }\r\n\r\n  _initShaderProgram(gl, vsSource, fsSource) {\r\n    const vertexShader = this._loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n    const fragmentShader = this._loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return null;\r\n    }\r\n    return shaderProgram;\r\n  }\r\n\r\n  _loadShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return null;\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      1.0, 1.0,\r\n      -1.0, 1.0,\r\n      1.0, -1.0,\r\n      -1.0, -1.0,\r\n    ];\r\n    const position = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, position);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const colors = [\r\n      1.0, 1.0, 1.0, 1.0,\r\n      1.0, 0.0, 0.0, 1.0,\r\n      0.0, 1.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0, 1.0\r\n    ];\r\n    const color = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, color);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    return { position, color };\r\n  }\r\n}\r\n\r\nexport default ColoredSquareScene;\r\n","import React from 'react';\r\nimport ColoredSquareScene from './ColoredSquareScene';\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.renderCanvas = this.renderCanvas.bind(this);\r\n    this.scene = new ColoredSquareScene();\r\n  }\r\n\r\n  componentDidMount() {\r\n    const canvas = this.canvas;\r\n    const rect = canvas.getBoundingClientRect()\r\n    canvas.width = rect.width;\r\n    canvas.height = rect.height;\r\n    this.gl = canvas.getContext('webgl');\r\n    if (this.gl === null) {\r\n      alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n    } else {\r\n      this.scene.initScene(this.gl);\r\n      this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.cancelAnimationFrame(this.frame);\r\n  }\r\n\r\n  renderCanvas(timeStamp) {\r\n    if (!this.timeStamp) {\r\n      this.timeStamp = timeStamp;\r\n    }\r\n    timeStamp *= 0.001;\r\n    const deltaTime = timeStamp - this.timeStamp;\r\n    this.timeStamp = timeStamp;\r\n    this.scene.drawScene(this.gl, deltaTime);\r\n    this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"screen\">\r\n        <canvas className=\"canvas\" ref={elem => this.canvas = elem}></canvas>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}