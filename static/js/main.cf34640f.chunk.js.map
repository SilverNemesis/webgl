{"version":3,"sources":["ColoredSquareScene.js","ColoredCubeScene.js","TexturedCubeScene.js","LightedCubeScene.js","App.js","serviceWorker.js","index.js"],"names":["ColoredSquareScene","this","initScene","bind","drawScene","gl","shaderProgram","_initShaderProgram","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexColor","uniformLocations","projectionMatrix","getUniformLocation","modelViewMatrix","buffers","_initBuffers","scene","squareRotation","deltaTime","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","type","FLOAT","bindBuffer","ARRAY_BUFFER","color","vertexAttribPointer","enableVertexAttribArray","position","fieldOfView","Math","PI","aspect","canvas","clientWidth","clientHeight","mat4","useProgram","uniformMatrix4fv","drawArrays","TRIANGLE_STRIP","vsSource","fsSource","vertexShader","_loadShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","alert","getProgramInfoLog","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","createBuffer","bufferData","Float32Array","STATIC_DRAW","ColoredCubeScene","cubeRotation","ELEMENT_ARRAY_BUFFER","indices","UNSIGNED_SHORT","drawElements","TRIANGLES","positionBuffer","faceColors","colors","j","length","c","concat","colorBuffer","indexBuffer","Uint16Array","TexturedCubeScene","textureCoord","uSampler","texture","_loadTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","uniform1i","textureCoordBuffer","url","createTexture","internalFormat","RGBA","srcFormat","srcType","UNSIGNED_BYTE","pixel","Uint8Array","texImage2D","image","Image","onload","_isPowerOf2","width","height","generateMipmap","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","src","value","LightedCubeScene","vertexNormal","normalMatrix","normal","normalBuffer","App","props","onClickCanvas","renderCanvas","scenes","init","render","sceneIndex","rect","getBoundingClientRect","getContext","frame","window","requestAnimationFrame","cancelAnimationFrame","event","preventDefault","timeStamp","className","ref","elem","onClick","React","Component","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cf34640f.chunk.js","sourcesContent":["import * as mat4 from 'gl-matrix/mat4';\r\n\r\nclass ColoredSquareScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = this._initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, squareRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.depthFunc(gl.LEQUAL);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.squareRotation, [0, 0, 1]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const offset = 0;\r\n      const vertexCount = 4;\r\n      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\r\n    }\r\n\r\n    scene.squareRotation += deltaTime;\r\n  }\r\n\r\n  _initShaderProgram(gl, vsSource, fsSource) {\r\n    const vertexShader = this._loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n    const fragmentShader = this._loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return null;\r\n    }\r\n    return shaderProgram;\r\n  }\r\n\r\n  _loadShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return null;\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      1.0, 1.0,\r\n      -1.0, 1.0,\r\n      1.0, -1.0,\r\n      -1.0, -1.0,\r\n    ];\r\n    const position = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, position);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const colors = [\r\n      1.0, 1.0, 1.0, 1.0,\r\n      1.0, 0.0, 0.0, 1.0,\r\n      0.0, 1.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0, 1.0\r\n    ];\r\n    const color = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, color);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    return { position, color };\r\n  }\r\n}\r\n\r\nexport default ColoredSquareScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\n\r\nclass ColoredCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = this._initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.depthFunc(gl.LEQUAL);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initShaderProgram(gl, vsSource, fsSource) {\r\n    const vertexShader = this._loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n    const fragmentShader = this._loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return null;\r\n    }\r\n    return shaderProgram;\r\n  }\r\n\r\n  _loadShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return null;\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const faceColors = [\r\n      [1.0, 1.0, 1.0, 1.0],    // Front face: white\r\n      [1.0, 0.0, 0.0, 1.0],    // Back face: red\r\n      [0.0, 1.0, 0.0, 1.0],    // Top face: green\r\n      [0.0, 0.0, 1.0, 1.0],    // Bottom face: blue\r\n      [1.0, 1.0, 0.0, 1.0],    // Right face: yellow\r\n      [1.0, 0.0, 1.0, 1.0],    // Left face: purple\r\n    ];\r\n    let colors = [];\r\n    for (let j = 0; j < faceColors.length; ++j) {\r\n      const c = faceColors[j];\r\n      colors = colors.concat(c, c, c, c);\r\n    }\r\n    const colorBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, color: colorBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default ColoredCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\n\r\nclass TexturedCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec2 aTextureCoord;\r\n\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying highp vec2 vTextureCoord;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying highp vec2 vTextureCoord;\r\n\r\n      uniform sampler2D uSampler;\r\n\r\n      void main(void) {\r\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n      }\r\n    `;\r\n\r\n    const shaderProgram = this._initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n        uSampler: gl.getUniformLocation(shaderProgram, 'uSampler')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    const texture = this._loadTexture(gl, 'images/cubetexture.png');\r\n\r\n    this.scene = { programInfo, buffers, texture, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers, texture } = scene;\r\n\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.depthFunc(gl.LEQUAL);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.textureCoord,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.uniform1i(programInfo.uniformLocations.uSampler, 0);\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initShaderProgram(gl, vsSource, fsSource) {\r\n    const vertexShader = this._loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n    const fragmentShader = this._loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return null;\r\n    }\r\n    return shaderProgram;\r\n  }\r\n\r\n  _loadShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return null;\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const textureCoordinates = [\r\n      // Front\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Back\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Top\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Bottom\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Right\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Left\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n    ];\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer };\r\n  }\r\n\r\n  _loadTexture(gl, url) {\r\n    const texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    const level = 0;\r\n    const internalFormat = gl.RGBA;\r\n    const width = 1;\r\n    const height = 1;\r\n    const border = 0;\r\n    const srcFormat = gl.RGBA;\r\n    const srcType = gl.UNSIGNED_BYTE;\r\n    const pixel = new Uint8Array([0, 0, 255, 255]);\r\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);\r\n    const image = new Image();\r\n    image.onload = () => {\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\r\n        srcFormat, srcType, image);\r\n      if (this._isPowerOf2(image.width) && this._isPowerOf2(image.height)) {\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n      } else {\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      }\r\n    };\r\n    image.src = url;\r\n    return texture;\r\n  }\r\n\r\n  _isPowerOf2(value) {\r\n    return (value & (value - 1)) === 0;\r\n  }\r\n}\r\n\r\nexport default TexturedCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\n\r\nclass LightedCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec3 aVertexNormal;\r\n      attribute vec2 aTextureCoord;\r\n\r\n      uniform mat4 uNormalMatrix;\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying highp vec2 vTextureCoord;\r\n      varying highp vec3 vLighting;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n\r\n        // Apply lighting effect\r\n\r\n        highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);\r\n        highp vec3 directionalLightColor = vec3(1, 1, 1);\r\n        highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\r\n\r\n        highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);\r\n\r\n        highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\r\n        vLighting = ambientLight + (directionalLightColor * directional);\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying highp vec2 vTextureCoord;\r\n      varying highp vec3 vLighting;\r\n\r\n      uniform sampler2D uSampler;\r\n\r\n      void main(void) {\r\n        highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\r\n\r\n        gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\r\n      }\r\n    `;\r\n\r\n    const shaderProgram = this._initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),\r\n        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n        normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),\r\n        uSampler: gl.getUniformLocation(shaderProgram, 'uSampler')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    const texture = this._loadTexture(gl, 'images/cubetexture.png');\r\n\r\n    this.scene = { programInfo, buffers, texture, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers, texture } = scene;\r\n\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.depthFunc(gl.LEQUAL);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexNormal,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.textureCoord,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      const normalMatrix = mat4.create();\r\n      mat4.invert(normalMatrix, modelViewMatrix);\r\n      mat4.transpose(normalMatrix, normalMatrix);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.normalMatrix,\r\n        false,\r\n        normalMatrix);\r\n    }\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.uniform1i(programInfo.uniformLocations.uSampler, 0);\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initShaderProgram(gl, vsSource, fsSource) {\r\n    const vertexShader = this._loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n    const fragmentShader = this._loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return null;\r\n    }\r\n    return shaderProgram;\r\n  }\r\n\r\n  _loadShader(gl, type, source) {\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return null;\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const normalBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n\r\n    const vertexNormals = [\r\n      // Front\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n\r\n      // Back\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n\r\n      // Top\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n\r\n      // Bottom\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n\r\n      // Right\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n\r\n      // Left\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);\r\n\r\n    const textureCoordinates = [\r\n      // Front\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Back\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Top\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Bottom\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Right\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Left\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n    ];\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, normal: normalBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer };\r\n  }\r\n\r\n  _loadTexture(gl, url) {\r\n    const texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    const level = 0;\r\n    const internalFormat = gl.RGBA;\r\n    const width = 1;\r\n    const height = 1;\r\n    const border = 0;\r\n    const srcFormat = gl.RGBA;\r\n    const srcType = gl.UNSIGNED_BYTE;\r\n    const pixel = new Uint8Array([0, 0, 255, 255]);\r\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);\r\n    const image = new Image();\r\n    image.onload = () => {\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\r\n        srcFormat, srcType, image);\r\n      if (this._isPowerOf2(image.width) && this._isPowerOf2(image.height)) {\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n      } else {\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      }\r\n    };\r\n    image.src = url;\r\n    return texture;\r\n  }\r\n\r\n  _isPowerOf2(value) {\r\n    return (value & (value - 1)) === 0;\r\n  }\r\n}\r\n\r\nexport default LightedCubeScene;\r\n","import React from 'react';\r\nimport ColoredSquareScene from './ColoredSquareScene';\r\nimport ColoredCubeScene from './ColoredCubeScene';\r\nimport TexturedCubeScene from './TexturedCubeScene';\r\nimport LightedCubeScene from './LightedCubeScene';\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.onClickCanvas = this.onClickCanvas.bind(this);\r\n    this.renderCanvas = this.renderCanvas.bind(this);\r\n    this.scenes = [\r\n      { init: false, render: new ColoredSquareScene() },\r\n      { init: false, render: new ColoredCubeScene() },\r\n      { init: false, render: new TexturedCubeScene() },\r\n      { init: false, render: new LightedCubeScene() }\r\n    ];\r\n    this.sceneIndex = this.scenes.length - 1;\r\n  }\r\n\r\n  componentDidMount() {\r\n    const canvas = this.canvas;\r\n    const rect = canvas.getBoundingClientRect()\r\n    canvas.width = rect.width;\r\n    canvas.height = rect.height;\r\n    this.gl = canvas.getContext('webgl');\r\n    if (this.gl === null) {\r\n      alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n    } else {\r\n      const scene = this.scenes[this.sceneIndex];\r\n      if (!scene.init) {\r\n        scene.init = true;\r\n        scene.render.initScene(this.gl);\r\n      }\r\n      this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.cancelAnimationFrame(this.frame);\r\n  }\r\n\r\n  onClickCanvas(event) {\r\n    event.preventDefault();\r\n    this.sceneIndex = (this.sceneIndex + 1) % this.scenes.length;\r\n    const scene = this.scenes[this.sceneIndex];\r\n    if (!scene.init) {\r\n      scene.init = true;\r\n      scene.render.initScene(this.gl);\r\n    }\r\n  }\r\n\r\n  renderCanvas(timeStamp) {\r\n    if (!this.timeStamp) {\r\n      this.timeStamp = timeStamp;\r\n    }\r\n    timeStamp *= 0.001;\r\n    const deltaTime = timeStamp - this.timeStamp;\r\n    this.timeStamp = timeStamp;\r\n    const scene = this.scenes[this.sceneIndex];\r\n    scene.render.drawScene(this.gl, deltaTime);\r\n    this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"screen\">\r\n        <canvas className=\"canvas\" ref={elem => this.canvas = elem} onClick={this.onClickCanvas}></canvas>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}