{"version":3,"sources":["utility.js","ColoredSquareScene.js","ColoredCubeScene.js","TexturedCubeScene.js","LightedCubeModel.js","LightedCubeScene.js","App.js","serviceWorker.js","index.js"],"names":["initShaderProgram","gl","vsSource","fsSource","vertexShader","_loadShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","alert","getProgramInfoLog","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","loadTexture","url","texture","createTexture","bindTexture","TEXTURE_2D","internalFormat","RGBA","srcFormat","srcType","UNSIGNED_BYTE","pixel","Uint8Array","texImage2D","image","Image","onload","_isPowerOf2","width","height","generateMipmap","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","src","value","clearScreen","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","ColoredSquareScene","this","initScene","bind","drawScene","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexColor","uniformLocations","projectionMatrix","getUniformLocation","modelViewMatrix","buffers","_initBuffers","scene","squareRotation","deltaTime","FLOAT","bindBuffer","ARRAY_BUFFER","color","vertexAttribPointer","enableVertexAttribArray","position","fieldOfView","Math","PI","aspect","canvas","clientWidth","clientHeight","mat4","useProgram","uniformMatrix4fv","drawArrays","TRIANGLE_STRIP","createBuffer","bufferData","Float32Array","STATIC_DRAW","ColoredCubeScene","cubeRotation","ELEMENT_ARRAY_BUFFER","indices","UNSIGNED_SHORT","drawElements","TRIANGLES","positionBuffer","faceColors","colors","j","length","c","concat","colorBuffer","indexBuffer","Uint16Array","TexturedCubeScene","textureCoord","uSampler","activeTexture","TEXTURE0","uniform1i","textureCoordBuffer","LightedCubeModel","draw","_initShaders","model","vertexNormal","normalMatrix","viewMatrix","modelMatrix","normal","normalBuffer","LightedCubeScene","actors","location","rotation","rotationSpeed","camera","cameraDir","i","actor","_renderActor","_animateActor","App","props","onClickCanvas","renderCanvas","scenes","init","render","sceneIndex","rect","getBoundingClientRect","getContext","frame","window","requestAnimationFrame","cancelAnimationFrame","event","preventDefault","timeStamp","className","ref","elem","onClick","React","Component","Boolean","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.990494d6.chunk.js","sourcesContent":["export function degreesToRadians(degrees) {\r\n  var pi = Math.PI;\r\n  return degrees * (pi / 180);\r\n}\r\n\r\nexport function initShaderProgram(gl, vsSource, fsSource) {\r\n  const vertexShader = _loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n  const fragmentShader = _loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n  const shaderProgram = gl.createProgram();\r\n  gl.attachShader(shaderProgram, vertexShader);\r\n  gl.attachShader(shaderProgram, fragmentShader);\r\n  gl.linkProgram(shaderProgram);\r\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n    return null;\r\n  }\r\n  return shaderProgram;\r\n}\r\n\r\nfunction _loadShader(gl, type, source) {\r\n  const shader = gl.createShader(type);\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n    gl.deleteShader(shader);\r\n    return null;\r\n  }\r\n  return shader;\r\n}\r\n\r\nexport function loadTexture(gl, url) {\r\n  const texture = gl.createTexture();\r\n  gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  const level = 0;\r\n  const internalFormat = gl.RGBA;\r\n  const width = 1;\r\n  const height = 1;\r\n  const border = 0;\r\n  const srcFormat = gl.RGBA;\r\n  const srcType = gl.UNSIGNED_BYTE;\r\n  const pixel = new Uint8Array([0, 0, 255, 255]);\r\n  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);\r\n  const image = new Image();\r\n  image.onload = () => {\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\r\n      srcFormat, srcType, image);\r\n    if (_isPowerOf2(image.width) && _isPowerOf2(image.height)) {\r\n      gl.generateMipmap(gl.TEXTURE_2D);\r\n    } else {\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    }\r\n  };\r\n  image.src = url;\r\n  return texture;\r\n}\r\n\r\nfunction _isPowerOf2(value) {\r\n  return (value & (value - 1)) === 0;\r\n}\r\n\r\nexport function clearScreen(gl) {\r\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n  gl.clearDepth(1.0);\r\n  gl.enable(gl.DEPTH_TEST);\r\n  gl.depthFunc(gl.LEQUAL);\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n}\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, clearScreen } from './utility'\r\n\r\nclass ColoredSquareScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, squareRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(\r\n        programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.squareRotation, [0, 0, 1]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const offset = 0;\r\n      const vertexCount = 4;\r\n      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\r\n    }\r\n\r\n    scene.squareRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      1.0, 1.0,\r\n      -1.0, 1.0,\r\n      1.0, -1.0,\r\n      -1.0, -1.0,\r\n    ];\r\n    const position = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, position);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const colors = [\r\n      1.0, 1.0, 1.0, 1.0,\r\n      1.0, 0.0, 0.0, 1.0,\r\n      0.0, 1.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0, 1.0\r\n    ];\r\n    const color = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, color);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    return { position, color };\r\n  }\r\n}\r\n\r\nexport default ColoredSquareScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, clearScreen } from './utility'\r\n\r\nclass ColoredCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n\r\n    uniform mat4 uModelViewMatrix;\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n      vColor = aVertexColor;\r\n    }\r\n  `;\r\n\r\n    const fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    this.scene = { programInfo, buffers, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 4;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexColor,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const faceColors = [\r\n      [1.0, 1.0, 1.0, 1.0],    // Front face: white\r\n      [1.0, 0.0, 0.0, 1.0],    // Back face: red\r\n      [0.0, 1.0, 0.0, 1.0],    // Top face: green\r\n      [0.0, 0.0, 1.0, 1.0],    // Bottom face: blue\r\n      [1.0, 1.0, 0.0, 1.0],    // Right face: yellow\r\n      [1.0, 0.0, 1.0, 1.0],    // Left face: purple\r\n    ];\r\n    let colors = [];\r\n    for (let j = 0; j < faceColors.length; ++j) {\r\n      const c = faceColors[j];\r\n      colors = colors.concat(c, c, c, c);\r\n    }\r\n    const colorBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, color: colorBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default ColoredCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { initShaderProgram, loadTexture, clearScreen } from './utility'\r\n\r\nclass TexturedCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec2 aTextureCoord;\r\n\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying highp vec2 vTextureCoord;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying highp vec2 vTextureCoord;\r\n\r\n      uniform sampler2D uSampler;\r\n\r\n      void main(void) {\r\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n      }\r\n    `;\r\n\r\n    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n    const programInfo = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n        uSampler: gl.getUniformLocation(shaderProgram, 'uSampler')\r\n      }\r\n    };\r\n\r\n    const buffers = this._initBuffers(gl);\r\n\r\n    const texture = loadTexture(gl, 'images/cubetexture.png');\r\n\r\n    this.scene = { programInfo, buffers, texture, cubeRotation: 0.0 };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n    const { programInfo, buffers, texture } = scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.vertexPosition,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(\r\n        programInfo.attribLocations.textureCoord,\r\n        numComponents,\r\n        type,\r\n        normalize,\r\n        stride,\r\n        offset);\r\n      gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    {\r\n      const fieldOfView = 45 * Math.PI / 180;\r\n      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      const zNear = 0.1;\r\n      const zFar = 100.0;\r\n      const projectionMatrix = mat4.create();\r\n      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n      const modelViewMatrix = mat4.create();\r\n      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation, [0, 0, 1]);\r\n      mat4.rotate(modelViewMatrix, modelViewMatrix, scene.cubeRotation * 0.7, [0, 1, 0]);\r\n      gl.useProgram(programInfo.program);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        projectionMatrix);\r\n      gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.modelViewMatrix,\r\n        false,\r\n        modelViewMatrix);\r\n    }\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.uniform1i(programInfo.uniformLocations.uSampler, 0);\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n\r\n    scene.cubeRotation += deltaTime;\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const textureCoordinates = [\r\n      // Front\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Back\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Top\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Bottom\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Right\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n      // Left\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n    ];\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      0, 1, 2, 0, 2, 3,   // front\r\n      4, 5, 6, 4, 6, 7,   // back\r\n      8, 9, 10, 8, 10, 11,   // top\r\n      12, 13, 14, 12, 14, 15,   // bottom\r\n      16, 17, 18, 16, 18, 19,   // right\r\n      20, 21, 22, 20, 22, 23,   // left\r\n    ];\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default TexturedCubeScene;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { loadTexture, initShaderProgram } from './utility'\r\n\r\nclass LightedCubeModel {\r\n  constructor(gl) {\r\n    this.gl = gl;\r\n    this.draw = this.draw.bind(this);\r\n    const shaderProgram = this._initShaders(gl);\r\n    this.model = {\r\n      program: shaderProgram,\r\n      attribLocations: {\r\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n        vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),\r\n        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord')\r\n      },\r\n      uniformLocations: {\r\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n        normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),\r\n        uSampler: gl.getUniformLocation(shaderProgram, 'uSampler')\r\n      },\r\n      buffers: this._initBuffers(gl),\r\n      texture: loadTexture(gl, 'images/cubetexture.png')\r\n    }\r\n  }\r\n\r\n  draw(projectionMatrix, viewMatrix, modelMatrix) {\r\n    const gl = this.gl;\r\n    const model = this.model;\r\n    const { buffers, texture } = this.model;\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\r\n      gl.vertexAttribPointer(model.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.vertexPosition);\r\n    }\r\n\r\n    {\r\n      const numComponents = 3;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);\r\n      gl.vertexAttribPointer(model.attribLocations.vertexNormal, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.vertexNormal);\r\n    }\r\n\r\n    {\r\n      const numComponents = 2;\r\n      const type = gl.FLOAT;\r\n      const normalize = false;\r\n      const stride = 0;\r\n      const offset = 0;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\r\n      gl.vertexAttribPointer(model.attribLocations.textureCoord, numComponents, type, normalize, stride, offset);\r\n      gl.enableVertexAttribArray(model.attribLocations.textureCoord);\r\n    }\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\r\n\r\n    const normalMatrix = mat4.create();\r\n    mat4.invert(normalMatrix, modelMatrix);\r\n    mat4.transpose(normalMatrix, normalMatrix);\r\n\r\n    const modelViewMatrix = mat4.create();\r\n    mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);\r\n\r\n    gl.useProgram(model.program);\r\n    gl.uniformMatrix4fv(model.uniformLocations.projectionMatrix, false, projectionMatrix);\r\n    gl.uniformMatrix4fv(model.uniformLocations.modelViewMatrix, false, modelViewMatrix);\r\n    gl.uniformMatrix4fv(model.uniformLocations.normalMatrix, false, normalMatrix);\r\n\r\n    {\r\n      gl.activeTexture(gl.TEXTURE0);\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.uniform1i(model.uniformLocations.uSampler, 0);\r\n\r\n      const vertexCount = 36;\r\n      const type = gl.UNSIGNED_SHORT;\r\n      const offset = 0;\r\n      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n    }\r\n  }\r\n\r\n  _initShaders(gl) {\r\n    const vsSource = `\r\n      attribute vec4 aVertexPosition;\r\n      attribute vec3 aVertexNormal;\r\n      attribute vec2 aTextureCoord;\r\n\r\n      uniform mat4 uNormalMatrix;\r\n      uniform mat4 uModelViewMatrix;\r\n      uniform mat4 uProjectionMatrix;\r\n\r\n      varying highp vec2 vTextureCoord;\r\n      varying highp vec3 vLighting;\r\n\r\n      void main(void) {\r\n        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\r\n        vTextureCoord = aTextureCoord;\r\n\r\n        // Apply lighting effect\r\n\r\n        highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);\r\n        highp vec3 directionalLightColor = vec3(1, 1, 1);\r\n        highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\r\n\r\n        highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);\r\n\r\n        highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\r\n        vLighting = ambientLight + (directionalLightColor * directional);\r\n      }\r\n    `;\r\n\r\n    const fsSource = `\r\n      varying highp vec2 vTextureCoord;\r\n      varying highp vec3 vLighting;\r\n\r\n      uniform sampler2D uSampler;\r\n\r\n      void main(void) {\r\n        highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\r\n\r\n        gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\r\n      }\r\n    `;\r\n\r\n    return initShaderProgram(gl, vsSource, fsSource);\r\n  }\r\n\r\n  _initBuffers(gl) {\r\n    const positions = [\r\n      // Front face\r\n      -1.0, -1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n\r\n      // Back face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, 1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n\r\n      // Top face\r\n      -1.0, 1.0, -1.0,\r\n      -1.0, 1.0, 1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, 1.0, -1.0,\r\n\r\n      // Bottom face\r\n      -1.0, -1.0, -1.0,\r\n      1.0, -1.0, -1.0,\r\n      1.0, -1.0, 1.0,\r\n      -1.0, -1.0, 1.0,\r\n\r\n      // Right face\r\n      1.0, -1.0, -1.0,\r\n      1.0, 1.0, -1.0,\r\n      1.0, 1.0, 1.0,\r\n      1.0, -1.0, 1.0,\r\n\r\n      // Left face\r\n      -1.0, -1.0, -1.0,\r\n      -1.0, -1.0, 1.0,\r\n      -1.0, 1.0, 1.0,\r\n      -1.0, 1.0, -1.0,\r\n    ];\r\n\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    const vertexNormals = [\r\n      // Front\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n      0.0, 0.0, 1.0,\r\n\r\n      // Back\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n      0.0, 0.0, -1.0,\r\n\r\n      // Top\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n      0.0, 1.0, 0.0,\r\n\r\n      // Bottom\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n      0.0, -1.0, 0.0,\r\n\r\n      // Right\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n      1.0, 0.0, 0.0,\r\n\r\n      // Left\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0,\r\n      -1.0, 0.0, 0.0\r\n    ];\r\n\r\n    const normalBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);\r\n\r\n    const textureCoordinates = [\r\n      // Front\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Back\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Top\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Bottom\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Right\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n\r\n      // Left\r\n      0.0, 0.0,\r\n      1.0, 0.0,\r\n      1.0, 1.0,\r\n      0.0, 1.0,\r\n    ];\r\n\r\n    const textureCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n\r\n    const indices = [\r\n      // Front\r\n      0, 1, 2, 0, 2, 3,\r\n\r\n      // Back\r\n      4, 5, 6, 4, 6, 7,\r\n\r\n      // Top\r\n      8, 9, 10, 8, 10, 11,\r\n\r\n      // Bottom\r\n      12, 13, 14, 12, 14, 15,\r\n\r\n      // Right\r\n      16, 17, 18, 16, 18, 19,\r\n\r\n      // Left\r\n      20, 21, 22, 20, 22, 23,\r\n    ];\r\n\r\n    const indexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n    return { position: positionBuffer, normal: normalBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer };\r\n  }\r\n}\r\n\r\nexport default LightedCubeModel;\r\n","import * as mat4 from 'gl-matrix/mat4';\r\nimport { clearScreen } from './utility'\r\nimport LightedCubeModel from './LightedCubeModel';\r\n\r\nclass LightedCubeScene {\r\n  constructor() {\r\n    this.initScene = this.initScene.bind(this);\r\n    this.drawScene = this.drawScene.bind(this);\r\n  }\r\n\r\n  initScene(gl) {\r\n    const model = new LightedCubeModel(gl);\r\n    this.scene = {\r\n      actors: [\r\n        {\r\n          model,\r\n          location: [-2.0, 0.0, -5.5],\r\n          rotation: 0.0,\r\n          rotationSpeed: 1.0\r\n        },\r\n        {\r\n          model,\r\n          location: [2.0, 0.0, -5.5],\r\n          rotation: 0.0,\r\n          rotationSpeed: 2.0\r\n        }\r\n      ],\r\n      camera: [0.0, 0.0, 0.0],\r\n      cameraDir: [0.0, 0.0, 8.0]\r\n    };\r\n  }\r\n\r\n  drawScene(gl, deltaTime) {\r\n    const scene = this.scene;\r\n\r\n    clearScreen(gl);\r\n\r\n    const fieldOfView = 45 * Math.PI / 180;\r\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n    const zNear = 0.1;\r\n    const zFar = 100.0;\r\n    const projectionMatrix = mat4.create();\r\n    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\r\n\r\n    const viewMatrix = mat4.create();\r\n    mat4.translate(viewMatrix, viewMatrix, scene.camera);\r\n    mat4.invert(viewMatrix, viewMatrix)\r\n\r\n    for (let i = 0; i < scene.actors.length; i++) {\r\n      const actor = scene.actors[i];\r\n      this._renderActor(projectionMatrix, viewMatrix, actor);\r\n      this._animateActor(deltaTime, actor);\r\n    }\r\n\r\n    if (scene.camera[2] > 64.0) {\r\n      scene.camera[2] = 64.0;\r\n      scene.cameraDir[2] = -8.0;\r\n    } else if (scene.camera[2] < 0.0) {\r\n      scene.camera[2] = 0.0;\r\n      scene.cameraDir[2] = 8.0;\r\n    }\r\n\r\n    scene.camera[0] += scene.cameraDir[0] * deltaTime;\r\n    scene.camera[1] += scene.cameraDir[1] * deltaTime;\r\n    scene.camera[2] += scene.cameraDir[2] * deltaTime;\r\n  }\r\n\r\n  _renderActor(projectionMatrix, viewMatrix, actor) {\r\n    const model = actor.model;\r\n\r\n    const modelMatrix = mat4.create();\r\n    mat4.translate(modelMatrix, modelMatrix, actor.location);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation, [0, 0, 1]);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation * 0.7, [0, 1, 0]);\r\n    mat4.rotate(modelMatrix, modelMatrix, actor.rotation * 0.3, [1, 0, 0]);\r\n\r\n    model.draw(projectionMatrix, viewMatrix, modelMatrix);\r\n  }\r\n\r\n  _animateActor(deltaTime, actor) {\r\n    actor.rotation += deltaTime * actor.rotationSpeed;\r\n  }\r\n}\r\n\r\nexport default LightedCubeScene;\r\n","import React from 'react';\r\nimport ColoredSquareScene from './ColoredSquareScene';\r\nimport ColoredCubeScene from './ColoredCubeScene';\r\nimport TexturedCubeScene from './TexturedCubeScene';\r\nimport LightedCubeScene from './LightedCubeScene';\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.onClickCanvas = this.onClickCanvas.bind(this);\r\n    this.renderCanvas = this.renderCanvas.bind(this);\r\n    this.scenes = [\r\n      { init: false, render: new ColoredSquareScene() },\r\n      { init: false, render: new ColoredCubeScene() },\r\n      { init: false, render: new TexturedCubeScene() },\r\n      { init: false, render: new LightedCubeScene() }\r\n    ];\r\n    this.sceneIndex = this.scenes.length - 1;\r\n  }\r\n\r\n  componentDidMount() {\r\n    const canvas = this.canvas;\r\n    const rect = canvas.getBoundingClientRect()\r\n    canvas.width = rect.width;\r\n    canvas.height = rect.height;\r\n    this.gl = canvas.getContext('webgl');\r\n    if (this.gl === null) {\r\n      alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n    } else {\r\n      const scene = this.scenes[this.sceneIndex];\r\n      if (!scene.init) {\r\n        scene.init = true;\r\n        scene.render.initScene(this.gl);\r\n      }\r\n      this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.cancelAnimationFrame(this.frame);\r\n  }\r\n\r\n  onClickCanvas(event) {\r\n    event.preventDefault();\r\n    this.sceneIndex = (this.sceneIndex + 1) % this.scenes.length;\r\n    const scene = this.scenes[this.sceneIndex];\r\n    if (!scene.init) {\r\n      scene.init = true;\r\n      scene.render.initScene(this.gl);\r\n    }\r\n  }\r\n\r\n  renderCanvas(timeStamp) {\r\n    if (!this.timeStamp) {\r\n      this.timeStamp = timeStamp;\r\n    }\r\n    timeStamp *= 0.001;\r\n    const deltaTime = timeStamp - this.timeStamp;\r\n    this.timeStamp = timeStamp;\r\n    const scene = this.scenes[this.sceneIndex];\r\n    scene.render.drawScene(this.gl, deltaTime);\r\n    this.frame = window.requestAnimationFrame(this.renderCanvas);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"screen\">\r\n        <canvas className=\"canvas\" ref={elem => this.canvas = elem} onClick={this.onClickCanvas}></canvas>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}